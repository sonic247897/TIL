> # Part 1: 프로그램의 구조와 실행
>
> 컴퓨터 시스템에 대한 탐구는 프로세서와 메모리 서브시스템으로 구성된 컴퓨터 자체를 공부하는 것으로 시작한다.
>
> - 응용 프로그램이 어떻게 표시되고 실행되는지에 대한 깊은 이해를 할 수 있게 된다.
> - 안전하고 안정적인 프로그램을 작성하고, 컴퓨팅 자원을 가장 잘 사용할 수 있도록 하는 기법을 배운다.

# 2장. 정보의 표현과 처리

`디지털 혁명` 이후, 현대의 컴퓨터는 **두 개의 값을 갖는 신호로 표현되는 정보(=`비트`)**를 저장하고 처리한다.

인간에게는 십진수 표기를 사용하는 것이 당연한 것이지만, **정보의 `저장`과 `처리`를 위한 기계**를 만들 때는 이진수 값들이 더 잘 동작한다.

- 두 개의 값을 갖는 신호를 저장하고 계산하기 위한 전자회로는 매우 간단하고 안정적이기 때문이다.

**목표**

- 여러 인코딩의 기본 정의로 시작해서,
  - 세 개의 가장 중요한 숫자 표현 - 비부호형 인코딩, 2의 보수 인코딩, 부동소수점 인코딩
- 표시 가능한 숫자의 범위,
  - 컴퓨터에서는 하나의 수를 인코딩하기 위해 **제한된** 개수의 비트를 사용한다. 그래서 결과값이 표시할 수 없을 정도로 큰 경우 `오버플로우`를 발생시킬 수 있다.
    - 정수 연산
      - 양수들 간의 곱셈 결과가 너무 크면 음수가 될 수 있다.
      - 곱셈에서 `교환법칙`과 `분배법칙`이 성립한다.
    - 부동소수점 연산
      - **양수들 간의 곱은 항상 양수**이지만, 오버플로우인 경우 특별한 값인 `+∞`를 만들어 낸다. 
      - 부동소수점 연산은 수의 제한된 정밀도 때문에 `교환법칙`이 성립하지 않는다.
- 비트수준 표시방법,
  - 비트수준 표시방법을 직접적으로 조작하여 **산술연산을 하는 여러 가지 방법**을 도출한다.
  - 산술식 계산 성능을 최적화하기 위해 `컴파일러`가 만들어 내는 기계어 코드를 이해하는 데 중요하다.
- 산술연산 성질 같은 특성을 도출한다.
  - 정수와 부동소수점 연산에서의 서로 다른 수학 특성은 그들이 **표시 방법의 유한성을 어떻게 처리하는지**에 기인한다.
  - **정수 표현은 비교적 작은 범위의 값을 인코딩하지만 매우 정밀하게 하는 반면, 부동소수점 표시는 넓은 범위의 값을 근사값으로만 인코딩해야 한다.**

> 이러한 내용은 **핵심 수학법칙**에 근거하여 설명된다.
>
> 프로그래머는 컴퓨터 산술연산이 어떻게 보다 익숙한 정수와 소수 연산에 연관되는지 완벽한 이해를 해야 하기 때문에 이러한 내용들을 이처럼 `추상적인 관점`에서 살펴보는 것이 중요하다.

``` c
*C++ 언어는 C언어를 기초로 완전히 동일한 숫자 표현과 연산을 사용하여 만들어졌다.
따라서 C언어에 대한 언급한 모든 내용은 C++에도 적용된다.
    =>광범위한 구현을 할 수 있도록 설계
*반면 자바 언어는 숫자 표현과 연산을 위해 새로운 표준을 만들었다.
    =>특정한 형식과 인코딩을 사용한다.
```

## 1. 정보의 저장

대부분의 컴퓨터들은 메모리의 비트에 접근할 때, 메모리에서 주소지정이 가능한 최소단위인 **바이트 단위**로 접근하는 방식을 사용한다.

**기계수준의 프로그램**은 메모리를 `가상메모리`라고 하는 거대한 바이트의 배열로 취급한다.

메모리의 각 바이트는 **주소**라고 하는 고유한 숫자로 식별할 수 있으며, 모든 가능한 주소들의 집합을 `가상 주소공간`이라고 부른다.

> 이름처럼 가상 주소공간은 **기계수준 프로그램에게 제공되는** 개념적인 이미지에 불과하다.
>
> 실제 구현은 DRAM, 플래시메모리, 디스크, 기타 하드웨어와 운영체제 소프트웨어로 이루어진다.

다음 장들에서는 어떻게 `컴파일러`와 `런타임 시스템`이 가상메모리 공간을 **분할**하고, 프로그램 객체(program object)들, 즉 프로그램 데이터, 인스트럭션, 제어정보 등을 **저장**하는지에 대해 다룰 것이다.

- 이러한 관리기법들은 모두 가상 주소공간 내에서 수행된다.

- C 컴파일러의 예시
  
  - C에서 어떤 **포인터의 값은**-정수, 구조체, 다른 프로그램 객체 등 유형에 관계없이-저장장치의 동일한 블록의 **첫 바이트의 가상주소**가 된다.
  
    => 기계수준 프로그램의 추상화 윗계층인 소스코드에서도 포인터 문법으로 가상 메모리에 접근할 수 있다.
  
  - C 컴파일러는 값의 타입에 따라 다른 기계수준 코드를 생성할 수 있다.
  
  - 비록 C 컴파일러가 타입 정보를 관리하지만, 컴파일러가 생성하는 실제 기계수준 프로그램은 데이터 타입에 대한 정보를 전혀 가지고 있지 않다.

### 1) 16진수 표시

C에서 0x나 OX로 시작하는 숫자 상수들은 16진수로 해석한다.

> 기계수준 프로그램으로 하게 되는 일반적인 작업은 비트 패턴을 십진, 이진, 16진수 간에 수동으로 변환하는 것이다.

- 이진수와 16진수 간의 변환은 한 번에 하나의 16진수 숫자에 대해 실행할 수 있으므로 즉각적으로 이루어진다.
  - 16진수 -> 이진수: 해당하는 십진수를 생각하여 이진수로 변환한다.
  - 이진수 -> 16진수: 4비트씩 나누어 16진수로 변환한다.
- 십진수와 16진수 표시 간의 변환은 **곱셈**과 **나눗셈**을 사용해야 한다.
  - 십진수 -> 16진수: x를 16으로 반복해서 나누고, 나머지를 나타내는 16진수 숫자를 least significant digit으로 사용한다.
  - 16진수 -> 십진수: 16진수 숫자들을 적절한 16의 제곱수로 곱해야 한다.

### 2) 데이터의 크기

모든 컴퓨터는 **워드 크기(word size)**를 규격으로 가지게 되는데, 이것은 `포인터`의 정규 크기를 표시한다.

> 하나의 가상주소가 한 개의 워드로 인코딩되기 때문에, **워드 크기가 결정하는 가장 중요한 시스템 변수는 `가상 주소공간의 최대 크기`**이다.
>
> - 즉, w비트 워드 크기를 갖는 컴퓨터에서 가상주소는 0에서 2^w - 1 범위를 가지며
> - 프로그램은 최대 2^w 바이트(`= 가상 주소공간의 크기*바이트`)에 접근할 수 있게 된다.

<img src="images/02_virtual_memory.JPG" style="zoom:70%;" />

*바이트(Byte)는 메모리에서 주소지정이 가능한 최소단위이다.*

- 32비트 워드 크기는 가상 주소공간의 크기를 4 GB(= 2^32 Byte), 약 4*(10^9) 바이트로 한정한다.
- 64비트 워드 크기는 16 Exabyte, 즉 1.84*(10^19) 바이트의 가상 주소공간으로 확장되었다.

대부분의 64비트 컴퓨터들은 역방향 호환성을 가지고 있어서 32비트 머신들을 위해 컴파일 된 프로그램들도 실행할 수 있다.

그렇기 때문에 어떤 프로그램이 실행되는 머신의 종류가 아니라 **프로그램이 어떻게 컴파일되었는가에 따라** "`32비트 프로그램`" 또는 "`64비트 프로그램`"이라고 부른다.

``` shell
linux> gcc -m32 prog.c
# 이 프로그램은 32비트나 64비트 머신 양쪽에서 정확하게 동작한다.
linux> gcc -m64 prog.c
# 이렇게 컴파일 한 프로그램은 64비트 머신에서만 실행된다.
```



ISO C99는 컴파일러와 컴퓨터 설정에 관계없이 데이터의 크기가 고정된 자료형들을 제안하였다.

- int32_t : 4바이트
- int64_t : 8바이트

> 고정된 정수형 크기를 이용하는 것이 프로그래머들이 **데이터의 표현을 안전하게 통제하는 최상의 방법**이다.

포인터는 프로그램의 워드 크기를 이용한다.

### 3) 주소지정과 바이트 순서

여러 바이트에 걸쳐 있는 **프로그램 객체**들에 대한 `관습` (거의 모든 컴퓨터에서 설정됨)

1. 무엇이 객체의 주소가 되어야 하는지

   : 사용된 바이트의 **최소 주소**

2. 메모리에 바이트들을 어떻게 정렬해야 하는지

   : 멀티 바이트 객체는 **연속된 바이트**에 저장됨



**어떤 객체를 나타내는 바이트들을 정렬**하는 데는 두 가지 일반적인 `관습`이 존재한다.

<img src="images/02_bit.JPG" style="zoom:67%;" />

w가 8의 배수라면 이 비트들은 바이트들로 나눌 수 있다.

- 가장 중요한 바이트(most significant byte)

  : [X*w-1*, X*w-2*, . . . , X*w-8*]

- 가장 덜 중요한 바이트(least significant byte)

  : [X*7*, X*6*, . . . , X*0*]

1. 리틀 엔디안

   : 객체를 메모리에 least significant byte부터 저장한다.

   - 대부분의 인텔 호환 머신들

2. 빅 엔디안

   : 객체를 메모리에 most significant byte부터 저장한다.

   - 대부분의 IBM과 Oracle 머신들

- "대부분" => 관례들은 회사라는 경계로 정확하게 나누어지지 않는다.

> 많은 최신 마이크로프로세서 칩들은 두 가지 방식으로 동작이 가능하도록 구성할 수 있다.
>
> 그러나 일단 특정 운영체제가 결정되면 바이트 순서는 고정되는 게 일반적이다.

ex) int형의 변수 x가 주소 0x100에 있으며, 16진수 값 0x01234567을 갖는다고 하자.

주소 범위 0x100 ~ 0x103까지의 바이트들의 순서는 컴퓨터의 타입에 따라 달라진다.

<img src="images/02_endian.JPG" style="zoom:70%;" />

> 위에서 **주소지정**과 **바이트 순서**에 대해 `관습`이라고 했던 이유는, 다른 관습 대신에 선택해야 하는 기술적 이유는 없기 때문이다.
>
> 하나의 관습이 선택되고 일정하게 지켜지는 한 선택은 상관이 없다.

그러나 때때로 바이트 순서가 이슈가 되기도 한다.

1. 이진 데이터가 **네트워크**를 통해 다른 컴퓨터로 전송될 때

   : 문제는 리틀 엔디안 컴퓨터에서 만들어진 데이터를 빅 엔디안 컴퓨터에 보내야 해서, 수신 측 프로그램에서는 워드들 내 바이트의 순서가 뒤바뀌는 경우이다.

   - `네트워크 응용프로그램`으로 작성된 코드는 송신 측 컴퓨터가 내부 표시를 **네트워크 표준**으로 변경하고,
   - 수신 측 컴퓨터가 **네트워크 표준**을 자신의 내부 표시방식으로 변환하도록 하는 `관습`을 따라야 한다.

2. 기계수준 프로그램에서 **정수 데이터**를 나타내는 바이트들을 해석할 때

   : 리틀 엔디안 컴퓨터를 위해 생성한 기계수준 프로그램을 해석할 때, 정수 데이터를 나타내는 바이트의 순서를 뒤집어야 실제 표현하고자 하는 정수를 알 수 있다.

   - `4004d3: 01 05 43 0b 20 00	add	%eax, 0x200b43(%rip)`

     이 라인은 인텔x86-64 프로세서용 기계수준 코드로, 역어셈블러에 의해 만들어졌다.

   - 이 바이트들의 마지막 4바이트인 `43 0b 20 00`을 **역순으로 `00 20 0b 43`라고 써야 원래 정수를 사람이 해석할 수 있다**. = 0x200b43

3. 프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때

   : 이러한 코딩 기술은 대부분의 응용 프로그램 작성시에 엄격히 제한되어야 하지만, 시스템-수준 프로그램에서는 상당히 유용하고 심지어 꼭 필요하기까지 하다.

   - C 언어에서 `캐스트(cast)`나 `유니온(union)`을 사용해서, 객체가 만들어졌을 때와는 **다른 타입의 데이터로 참조**될 수 있도록 할 수 있다.
   
   - 아래 코드의 예시는, C 프로그램의 멀티 바이트 객체들인 int, float, void *가 저장하고 있는 `값(멀티 바이트)`을 인간이 읽기 쉽고 이해하기 쉬운 **16진수 형식**으로 출력하는 코드이다. 
     

  => 그러나 빅 엔디안과 리틀 엔디안의 출력값이 달라서 의도하지 못한 결과가 나올 수 있다.
     
     - 그러기 위해서 각 1 바이트의 `비트패턴`을 **unsigned char 인코딩(1장에 의하면 컨텍스트)**을 이용해서 해석하면 `음이 아닌 정수`로 **해석**된다. 
     
       (실제 저장된 값과는 다르다. int형은 2의 보수법 인코딩을 사용하고 unsigned char형은 비부호형 인코딩을 사용하므로, 음의 정수를 양의 정수로 해석한다.)
     
     - 그 결과를 printf를 이용하여 16진수로 출력한다.

   ``` c
   #include <stdio.h>
   
   typedef unsigned char* byte_pointer;
   
   void show_bytes(byte_pointer start, size_t len){ // len은 바이트 수
       type_t
       for(i = 0; i < len; ++i)
           printf(" %.2x", start[i]);
       printf("\n");
   }
   
   void show_int(int x){
       // 이 캐스트는 이 포인터가 본래의 데이터 타입을 갖는 하나의 '객체를 가리키는 것이 아니라'
       // '일련의 바이트들을 가리킨다는 것'을 컴파일러에게 지시한다.
       show_bytes((byte_pointer) &x, sizeof(int));
   }
   
   void show_float(float x){
    show_bytes((byte_pointer) &x, sizeof(float));
   }

   void show_int(void* x){
       show_bytes((byte_pointer) &x, sizeof(void*));
   }
   ```

   - show_int의 경우 (워드크기= 32bit 컴퓨터, 리틀 엔디언)
   
     <img src="images/02_example_int.JPG" style="zoom:80%;" />
     
   - 빅 엔디언인 경우 출력은 `00 20 0b 43`이 된다.

   > int와 float 데이터의 바이트들은 **바이트 순서**를 제외하고는 모든 컴퓨터에서 동일한 결과를 얻었다.
   >
   > 반면에 포인터 값들은 완전히 다른 결과를 얻었다.
   >
   > 서로 다른 컴퓨터=운영체제 구성은 **저장장치의 할당**에 있어서 서로 다른 `관습`을 사용하기 때문이다.

### 4) 스트링의 표시

C에서 스트링은 `null(값 0을 갖는)` 문자로 종료하는 문자열로 인코딩된다.

<u>각 문자</u>는 표준 인코딩에 따라 표시되며, 이 중 가장 일반적인 인코딩이 **ASCII 문자코드**이다.

=> 스트링 타입은 각 문자별로 ASCII 인코딩을 하는데, **문자 인코딩은 멀티 바이트가 아니므로 바이트 순서 이슈가 발생하지 않는다**.

- UTF-8(유니코드 구현체)은 바이트 순서 이슈가 발생하지 않아서 주로 사용된다.
- UTF-16과 UTF-32는 멀티 바이트 인코딩이므로 바이트 순서 이슈가 발생한다. (UTF-16 : `자바 char` 표준) 

> 따라서 **ASCII를 문자코드로 사용하는 모든 컴퓨터에서** 바이트 순서나 워드 크기와 무관하게 show_bytes의 결과가 똑같다.
>
> ex) show_bytes("12345", 6) 의 결과 = 31 32 33 34 35 00
>
> - 그 결과 텍스트 데이터는 이진 데이터보다 `플랫폼 독립적`이다.

### 5) 코드의 표현

이진 코드(기계어 코드, `인스트럭션 인코딩`)는 컴퓨터와 운영체제들의 여러 가지 조합들 간에 호환성을 갖는 경우가 드물다.

``` c
int sum(int x, int y){
    return x+y;
}
```

위와 같은 C 함수를 여러 컴퓨터들에서 컴파일하면, 각자 다른 바이트 표시를 갖는 기계어 코드를 생성한다.

> 컴퓨터 시스템에서 근본 개념은 컴퓨터의 관점에서 볼 때 프로그램이라는 것은 단순히 바이트의 연속이라는 것이다.
>
> 컴퓨터는 디버깅 시 도움을 주기 위해 관리하는 일부의 **보조용 표**를 제외하고는 본래의 소스 프로그램에 대한 정보를 전혀 가지고 있지 않다.

``` c
*ASCII 문자집합은 영어 문서를 인코딩하는 데는 적합하지만 다른 언어로 된 문서를 인코딩하는 데는 
 전혀 적합하지 못하다.
*유니코드(Universal Character Set)
    : 기본 인코딩은 32비트 문자 표시를 사용한다.
     이 방법을 사용하면 문자열들이 4바이트로 인코딩되는 문자들의 연속으로 이루어져야 한다.
*UTF-8
    : 유니코드에서 변형된 인코딩.
     자주 사용되는 문자들은 1 또는 2바이트를 사용하고,그렇지 않은 문자들은 더 많은 바이트를 사용해서 인코딩한다.
	각 문자를 바이트의 연속으로 인코딩해서 표준 ASCII 문자들은 ASCII에서와 동일한 단일 바이트 인코딩을 사용한다.
```

- 자바는 스트링을 표시할 때 유니코드를 사용한다. C에서도 유니코드를 지원하기 위한 프로그램 라이브러리를 제공한다.

### 6) 부울Boolean 대수

1850년경 George Boole은 이진수 값 1과 0을 논리값 TRUE와 FALSE로 `인코딩`하면 *논리 추론의 기본 원리*들을 구현할 수 있는 **대수학을 수식화**할 수 있다는 점을 발견하였다.

- 각 `부울 대수 연산(~, &, |, ^)`은 `논리연산(NOT¬, AND∧, OR∨, EXCLUSIVE-OR⊕)`에 대응한다.

  즉, ~, &, |, ^ 연산자는 논리연산 NOT, AND, OR, EXCLUSIVE-OR을 각각 `인코딩`한다.

후에 정보이론 학문분야를 개척한 Claude Shannon이 최초로 부울 대수와 디지털 논리회로를 연계하였다.

- 부울 대수는 `디지털 시스템`의 설계와 해석에 중요한 역할을 하고 있다.

**[비트 벡터로 확장]**

네 가지 부울 연산을 0과 1로 이루어진 길이 w의 숫자 스트링인 `비트 벡터`에도 적용할 수 있다.

<img src="images/02_bit_vector.JPG" style="zoom:80%;" />

**응용에 따라서** 비트벡터의 각 대응하는 원소들에 대해 연산을 정의할 수 있다.

- `a & b`는 길이가 w인 비트 벡터로, `a & b`의 i번째 원소는 0 ≤ i ＜ w인 i에 대해 a*i* & b*i*로 정의할 수 있다.

- 연산 `|, ^, ~`도 같은 방식으로 비트 벡터에 확장할 수 있다.

``` dc
*부울 대수와 부울 링(ring)
	: 부울 연산 |, &, ~를 길이 w(w>0)의 비트 벡터에 대해 실행하면 [부울 대수]가 된다.
**부울 대수의 특성
	1. &연산은 |에 대해 분배법칙이 성립한다.
		a&(b|c) = (a&b)|(a&c)
	   |연산은 &에 대해 분배법칙이 성립한다.
	    a|(b&c) = (a|b)&(a|c)
	2. 부울 링(연산)
		: ^, &, ~ 같은 연산들을 길이 w의 비트 벡터에 적용할 때는 부울 링이라고 하는 다른 수학적 형태를 얻게 된다.
		부울 링은 정수 산술연산과 많은 공통점을 갖는다.
		[^와 "덧셈" 연산]
			^연산에서는 각 원소 자신이 ^에 대한 역이 된다.
			a^0 = a (0은 ^연산의 항등원)
			a^a = 0 (각 원소 자신은 ^연산의 역원)
		이 특성은 항들의 순서를 바꾸고 다른 순서로 묶는 경우에도 성립한다. (a^b)^a = b
		이 특성은 몇 개의 재미있는 결과와 교묘한 기법들을 만들어준다.
```

**응용1.** 유한집합의 표시

​	: 비트 벡터를 사용해서 집합을 `인코딩`한다.

​	i ∈ A이면 a*i* = 1인 비트 벡터 [a*w-1*, . . . , a*1*, a*0*]를 갖는 부분집합 A ⊆ {0, 1, . . . , w-1}을 `인코딩` 할 수 있다. 

​	ex) 비트 벡터 a = [01101001]은 집합 A = {0, 3, 5, 6}을 인코딩 한다.

- `집합 인코딩`에서 부울연산 인코딩
  - | : 합집합 연산
  - & : 교집합 연산
  - ~ : 여집합(complement)

### 7) C에서의 비트수준 연산

C에서는 비트들 간의 **부울 연산**을 지원한다.

- 이 연산은 모든 "완전한" 자료형들에 대해서 적용될 수 있다.

<img src="images/02_bit_operation.jpg" style="zoom:50%;" />

비트수준 연산은 일반적으로 `마스크 연산`을 구현할 때 사용한다.

- **마스크**는 일종의 비트 패턴으로, 워드 중에 일부 선택된 비트 집합을 표시한다.
  - x & 0xFF : 다른 바이트는 0으로 하고, x의 least significant byte만으로 구성된 값을 나타냄
  - ~0 : 프로세서의 데이터 표현의 크기와 관계없이 비트가 모두 1인 마스크를 만든다. **(호환성)**

### 8) C에서의 논리 연산

C에서는 **논리 연산**의 OR, AND, NOT에 해당하는 논리연산자 ||, &&, ! 을 제공한다.

> 비트수준 연산과 이들의 동작은 전혀 다르다.

**차이점 1.**

- 논리 연산은 0이 아닌 인자들을 '참'으로 취급하고, 0은 '거짓'으로 처리한다.

- 결과가 참이면 1, 거짓이면 0을 리턴한다.

<img src="images/02_logic_operation.jpg" style="zoom:50%;" />

**인자들이 0이나 1로 제한되는 특별한 경우에만 `비트단위 연산`과 이에 대응하는 논리 연산이 동일한 동작을 한다.** 

**차이점2.**

논리연산자는 수식의 결과가 첫 번째 인자를 계산해서 결정될 수 있으면 두 번째 인자는 계산하지 않는다.

- a && 5/a 는 division by zero 오류를 절대 발생시키지 않는다.
- p && *p++ 는 널 포인터의 역참조를 절대 발생시키지 않는다. 

### 9) C에서의 쉬프트 연산

C는 비트 패턴을 좌우로 이동시키는 **쉬프트 연산** 집합을 제공한다.

- 좌측 쉬프트 연산

  : x<<k . 좌측의 k비트가 밀려서 삭제되며 우측에는 k개의 **0으로 채워진다**.

- 우측 쉬프트 연산

  : x>>k . 일반적으로 컴퓨터는 두 종류의 `우측 쉬프트`를 제공한다.

  - 논리 우측 쉬프트

    : 좌측 끝을 k개의 **0들로 채운다**.

  - 산술 우측 쉬프트

    : 좌측 끝을 k개의 **most significant bit들로 채운다**.

    `부호형 정수 데이터`의 연산에서 유용하게 작용한다.

**[C 표준 vs 자바]**

- C 표준은 `부호형 숫자`의 경우에 어떤 타입의 우측 쉬프트가 사용되어야 하는지 명확히 정의하고 있지 않다.

  산술 또는 논리 쉬프트 둘 다 사용 가능하므로, 호환성 문제를 만날 가능성이 있다.

  - 그러나 실제로는 대부분의 컴파일러/컴퓨터 조합들은 `부호형 데이터`에 대해서 **산술 우측 쉬프트**를 사용하고 있다.
  - `비부호형 데이터`에 대해서는 **논리 우측 쉬프트**를 사용해야 한다.

- 자바는 우측 쉬프트가 어떻게 실행되는지에 대해 정확한 정의를 하고 있다.

  - x>>k : x를 산술적으로 쉬프트
  - x>>>k : 논리적으로 쉬프트



## 2. 정수의 표시

정수를 인코드하기 위해 사용할 수 있는 두 가지 방법

1. 양수만 표시할 수 있는 방법
2. 음수, 0, 양수 모두를 표시할 수 있는 방법

- 이들은 **수학적 특성**으로 볼 때, 그리고 이들의 **기계수준 구현**을 볼 때 매우 연관되어 있다.

<img src="images/02_summary.jpg" style="zoom:50%;" />

### 1) 정수형 데이터 타입

C는 다양한 *정수형*(≠정수) 데이터 타입-정수의 유한한 범위를 나타내는 데이터 타입-을 지원한다.

- 유일하게 컴퓨터에 의존적인 범위로 표시된 것은 크기 지정어 `long`에 대해서다.
  - 64비트 프로그램 - 8바이트 표시
  - 32비트 프로그램 - 4바이트 표시
- 중요한 특징은 범위들이 대칭이 아니라는 것이다. 음수의 범위가 양의 범위보다 1 더 넓다.

> C 표준에서는 각 데이터 타입에서 나타낼 수 있어야 하는 **최소한의 범위**를 정의한다.
>
> - C와 C++는 부호형(기본 설정)과 비부호형을 지원한다. 자바는 부호형만을 지원한다.
> - 표준에서는 양과 음의 숫자들이 대칭적인 범위만을 갖도록 요구하고 있다.
>   - 고정길이 자료형들(int32_t, uint32_t, int64_t, uint64_t)의 범위는 음의 영역과 양의 영역의 비대칭성을 만족해야 하며, 컴퓨터의 워드 크기와 컴파일러에 상관 없이 모든 프로그램에서 이 범위를 지켜야 한다.
> - int형은 최소 2바이트 숫자들로 구현될 수 있다.

<img src="images/02_standard_type.jpg" style="zoom:50%;" />

### 2) 비부호형의 인코딩

`비트 벡터 x`를 **이진수 표시로 작성된 <u>숫자</u>**로 생각하면 x의 `비부호형 해석(인코딩)`을 할 수 있다.

전체 해석과정을 `함수` B2U*w*(= 길이 w의 "binary에서 unsigned로"의 의미)로 **정의**하면,

1. 비트 벡터 x를 **이진수 표시로 작성된 숫자**로 표현한다.
2.  x*i*의 각 비트들은 0이나 1을 값으로 갖는데, 1인 경우는 2^i 값을 숫자의 값을 계산할 때 포함한다.

<img src="images/02_B2U.JPG" style="zoom:80%;" />

> 비부호형 이진수 표시는 0과 2^w - 1 사이의 모든 숫자가 **`w비트` 값으로 유일한 인코딩을 갖는다(함수적 측면에서 전단사 특성을 가짐)**는 중요한 특징을 나타낸다.
>
> - ex) 십진수 11은 유일한 비부호형 4비트 표시인 [1011]이 존재한다.

이 특성을 수학적 법칙을 이용해서 **정의**한다. (= 이름 붙여준다. 예를 들어 '유일성'이라는 이름)

- 유일성

  : 함수 B2U*w*는 `전단사(bijection)` 특성을 갖는다.

  - 전단사 특성은 어떤 함수 *f*가 양방향으로 사상할 수 있다는 것을 말한다.
  - y = *f*(x)라고 할 때, 역함수 x = *f-1*(y)도 성립한다.

  함수 B2U*w*는 길이 w의 각 비트 벡터들을 0과 2^w - 1 사이의 유일한 수로 매핑하며 그 **역함수**도 구할 수 있다.

  U2B*w*("unsigned to binary")로 표시하며 0과 2^w - 1 사이의 모든 수를 유일한 w비트 패턴으로 매핑한다.

### 3) 2의 보수(two's complement) 인코딩

부호형 숫자를 컴퓨터에서 표시하는 가장 일반적인 방법은 `2의 보수` 형식이라고 알려져 있다.

이것은 워드의 가장 중요한 비트를 음수 자리값을 갖는 것으로 해석(인코딩)하는 형태로 **정의**된다.

이러한 해석과정을 `함수` B2T*w*(= "binary에서 길이 w의 two's complement로"의 의미)로 **정의**하면,

<img src="D:\TIL\CS\CS-APP\images\02_B2T.JPG" style="zoom:67%;" />

1. most significant bit인 X*w-1*은 `부호 비트`라고 부른다.

   이 비트의 weight는 **- 2^(w-1)**이고, 이 값은 weight를 비부호형 표현한 것(`2^(w-1)`)을 음수화(`"-"`)한 것이다.


- w비트 2의 보수로 나타낼 수 있는 값의 범위

  - 가장 작은 수

    : 비트 벡터 [1 0 . . . 0] => 정수값 TMin*w* = - 2^(w-1)

  - 가장 큰 수

    : 비트 벡터 [0 1 . . . 1] => 정수값 TMax*w* = 2^(w-1) - 1

- 유일성

  : 함수 B2T*w*는 `전단사(bijection)` 특성을 갖는다.

  함수 B2T*w*는 길이 w의 각 비트 벡터들을 - 2^(w-1) 과 2^(w-1) - 1 사이의 유일한 수로 매핑하며 그 **역함수**도 구할 수 있다.

  T2B*w*("2의 보수를 이진수로")로 표시하며 - 2^(w-1) 과 2^(w-1) - 1 사이의 모든 수를 유일한 w비트 패턴으로 매핑한다.

**[중요한 숫자들]**

![](images/02_numbers.jpg)

- `2의 보수`의 범위는 **비대칭적**이다.

  : |T*Min*| = |T*Max*| + 1, 즉 T*Min*에 대해서는 대응되는 양수 값이 없다.

  - 이런 사실로 인해 `2의 보수 산술연산`에서 기이한 특성들을 갖게 되며, 난해한 프로그램 **오류**의 원인이 될 수 있다.

  - 비대칭성의 원인은 비트 패턴의 절반(부호비트가 1)이 음수를 표시하고, 나머지 절반(부호비트가 0)이 비음수(nonnegative)를 표시하기 때문이다.

    **0이 비음수**이므로 이것은 양수의 개수가 음수보다 1 적다는 것을 의미한다.

- `비부호형` 최대값은 `2의 보수` 최대값의 두 배보다 1 크다.

  : U*Max* = 2\*T*Max* + 1

- 정수 -1의 `2의 보수형`에서 비트 표시는, `비부호형`에서 비트가 모두 1인 U*Max*의 비트표시와 같다.

- 정수 0은 양쪽의 경우에 모두 비트가 0인 스트링으로 표시한다.



> C 표준에서는 부호형 정수를 `2의 보수 형식`으로 나타낼 것을 요구하지는 않지만, 거의 모든 컴퓨터에서 요구하고 있다.

- C 라이브러리의 <limits.h> 파일은 **컴파일러가 동작하는 특정 머신**에서의 여러 가지 정수 데이터 타입의 범위를 한정하는 상수들을 정의한다.
  - 상수 INT_MAX, INT_MIN, UINT_MAX를 정의

``` c
*고정 크기 정수형
    : 어떤 프로그램에서는 데이터 타입이 특정 크기를 함께 표시하는 인코딩을 해야 하는 경우가 있다.
    ex) 표준 프로토콜에 따라 인터넷으로 통신할 수 있게 해주는 프로그램을 작성할 때, 
	데이터 타입이 프로토콜에 의해 명시된 데이터 타입과 '호환성'이 있도록 하는 것이 중요하다.
    - 특히 C 표준은 데이터 타입들의 최소 범위만을 정의할 뿐 정확한 범위는 정의하지 않기 때문에, 호환성을 보장할 수는 없다.
    - ISO C99 표준은 stdint.h 파일에 고정크기의 정수 타입들을 소개하고 있다.
      이 파일은 intN_t나 uintN_t 같은 형식의 선언으로 데이터 타입들을 정의한다.
      (N의 정확한 값은 구현에 따라 다르지만, 대부분의 컴파일러는 8, 16, 32, 64를 허용한다)
        ex) 비부호형, 16비트 변수: uint16_t
            부호형, 32비트 변수: int32_t
**연관된 매크로들
    - 최소값과 최대값을 정의하는 매크로들도 있다.
      ex) INT32_MIN, INT64_MAX, UINT32_MAX
    - 고정길이의 자료형으로 규격화된 화면인쇄(printf 포맷 등)를 하기 위해서는 
      포맷 스트링을 시스템에 의존적인 방식으로 확장하는 매크로를 사용해야 한다.
      ex) int32_t 타입의 변수 x, int64_t 타입의 변수 y 출력
      	  printf("x = %" PRId32 ", y = %" PRIu64 "\n", x, y);
	- 64비트 프로그램으로 컴파일 할 때, 매크로 PRId32는 스트링 "d"로, PRIu64는 스트링 "l"과 "u"로 확장된다.
      C 전처리기가 스페이스(또는 다른 빈칸 문자)로 나누어진 연속된 스트링 상수들을 만나면 이들을 하나로 연결한다
          printf("x = %d, y = %lu\n", x, y);      
```

> 자바 표준은 정수 데이터 타입의 범위와 표시를 상당히 구체적으로 하고 있다.
>
> - 64비트의 경우에 대해 정확한 범위를 갖는 `2의 보수` 표시를 요구한다.
> - 단일 바이트 데이터 타입은 char 대신 `byte`라고 부른다.
>   - 자바 `char`형은 **UTF-16(유니코드 구현체)** 인코딩을 따르기 때문에 **2바이트**이다.

- 부호형 수의 또 다른 표시방법
     - 1의 보수(**Ones'** Complement)

          : MSB의 weight가 - 2^(w-1)이 아니라 -(2^(w-1) - 1)이라는 점 외에는 2의 보수와 동일하다.

          1의 보수 표시를 따르는 컴퓨터들은 과거에 만들어진 것들이다.

          - B2Ow(x) = - X*w-1*(2^(w-1) - 1) + ∑i=[0,w-2] X*i* * 2^i
          - `+0` : [00 ... 0]
          - `-0` : [11 ... 1]

     - 부호-크기

          : MSB는 부호비트가 된다.

          **부호 크기 인코딩 방식은 `부동소수점` 숫자들에서 사용된다.**

          - B2Sw(x) = (-1)^X*w-1* * (∑i=[0,w-2] X*i* * 2^i)
          - `+0` : [00 ... 0]
          - `-0` : [10 ... 0]

  - 이 두 가지 표시방식은 **0에 대해 2개의 서로 다른 인코딩이 존재**한다는 특성을 갖는다.

### 4) 비부호형과 부호형 간의 변환

C는 서로 다른 숫자 데이터 타입들 간에 `캐스팅(casting)`을 허용한다.

- 부호형 값을 비부호형으로, 비부호형을 부호형으로 캐스팅하는 효과는 무엇이 되어야 할까?

- 대부분의 C에서 이 질문에 대한 대답은 `숫자의 관점`에서가 아닌 `비트수준의 관점`에 기초한다.

  : 캐스팅의 효과가 **비트의 값들은 동일하게 유지**하지만 이들 **비트를 해석하는 방법은 변경**한다.

``` c
unsigned u = 4294967295u; /* UMax */
int	tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
```

결과(`2의 보수` 컴퓨터에서 실행):

``` c
u = 4294967295, tu = -1
```

- UMax를 표시하는 비트 패턴과 -1의 2의 보수 비트패턴은 동일하다.

> C에서 **동일한 길이**를 갖는 `부호형`과 `비부호형` 숫자들 간의 변환을 다루는 일반적인 방법은
>
> 숫자 값은 변할 수 있지만, 비트 패턴은 변하지 않는 것이다.

**[비트 패턴에 대한 2의 보수와 비부호형 값 사이의 관계]**

두 값 사이의 관계는 **`합성함수` T2U의 특성(법칙)**으로 표현할 수 있다.

​	T2U*w*(x) = B2U*w*(T2B*w*(x))

역함수도 존재한다.

​	U2T*w*(x) = B2T*w*(U2B*w*(x))

- h(x) = g(f(x))의 역함수는 h*-1*(x) = f*-1*(g*-1*(x))

**법칙**

1. `2의 보수`에서 `비부호형`으로의 변환

   : TMin*w* ≤ x ≤ TMax*w*를 만족하는 x에 대해

   <img src="images/02_T2U.JPG" style="zoom:80%;" />

   MSB의 자리값은 `2의 보수`에서는 - 2^(w-1)이고, `비부호형`에서는 + 2^(w-1)이어서 **이들의 차이는 2^w**이 된다.

   - T2U*16*(-12345) = -12345 + 2^16 = 53191
   - T2U*w*(-1) = -1 + 2^w = UMax*w*

   **유도**

   이러한 특성은 `함수` B2U*w*와 B2T*w*의 수식을 비교하면 유도할 수 있다.

   - 비교: B2U*w*(x) - B2T*w*(x) = 2\*(X*w-1* * 2^(w-1)) = X*w-1* * 2^w

   - 따라서 B2U*w*(x) = B2T*w*(x) + X*w-1* * 2^w 

     - MSB가 0이면, 즉 음수가 아닌 정수라면 B2U*w*(x) = B2T*w*(x)
     - MSB가 1이면, 즉 음수라면 B2U*w*(x) = B2T*w*(x) **+ 2^w**

     ∴ T2U*w*(x) = B2U*w*(T2B*w*(x)) 

     ​				   = **B2T*w*(T2B*w*(x))** + X*w-1* * 2^w 

     ​				   = **x** + X*w-1* * 2^w

   <img src="images/02_T2U_pic.JPG" style="zoom:70%;" />

   > 부호형 숫자를 대응하는 비부호형으로 매핑할 때,
   >
   > 음수들은 더 큰 양수들로 변환되지만, 비음수들은 변하지 않고 그대로 남는다.

2. `비부호형`에서 `2의 보수형`으로의 변환

   : 0 ≤ u ≤ UMax*w*인 에 대해서

   <img src="images/02_U2T.JPG" style="zoom:80%;" />

   **유도**

   이러한 특성은 **법칙1.**과 비슷하게 `함수` B2U*w*와 B2T*w*의 수식을 비교하면 유도할 수 있다.

   구하려는 함수가 `합성함수` U2T*w*(u) = B2T*w*(U2B*w*(u))이므로, 비교한 수식을 B2T*w*에 대해 정리하면 된다.

   - 비교: B2U*w*(u) - B2T*w*(u) = 2\*(U*w-1* * 2^(w-1)) = U*w-1* * 2^w

   - 따라서 B2T*w*(u) = B2U*w*(u) - U*w-1* * 2^w 

     - MSB가 0이면, 즉 2^(w-1) - 1(`=TMaxw`)보다 작거나 같은 정수라면 B2T*w*(u) = B2U*w*(u)
     - MSB가 1이면, 즉 2^(w-1) - 1(`=TMaxw`)보다 큰 정수라면 B2U*w*(u) = B2T*w*(u) **- 2^w**

     ∴ U2T*w*(u) = B2T*w*(U2B*w*(u)) 

     ​				   = **B2U*w*(U2B*w*(u))** - U*w-1* * 2^w 

     ​				   = **u** - U*w-1* * 2^w

   <img src="images/02_U2T_pic.JPG" style="zoom:70%;" />

   > 작은(≤ TMax*w*) 수에 대해서, 비부호형에서 부호형으로의 변환은 숫자 값을 그대로 유지한다.
   >
   > 큰(> TMax*w*) 수들은 음수값으로 변환된다.

함수들은 비트패턴을 정수로 해석할 뿐, 비트를 변경하지 않으므로

그 함수들을 합성한 합성함수에 대해서도 입력값과 출력값(결과)의 **비트패턴은 변하지 않는다**.

> 범위 0 ≤ x ≤ TMax*w*를 갖는 x 값에 대해서 T2U*w*(x) = x이고, U2T*w*(x) = x이다.
>
> 즉, 이 범위의 수들은 동일한 비부호형과 2의 보수 표시를 갖는다. 
>
> 이 범위 밖의 값들에 대해 변환하면 2^w를 더하거나 빼야 한다.

### 5) C에서 부호형과 비부호형의 비교

**[변환]**

C는 비부호형과 부호형 간의 `변환`을 **허용**하지만, **C 표준에서 변환이 어떻게 이루어져야 하는지 명확하게 언급하고 있지는 않다**.

하지만 대부분의 시스템은 바로 위에서와 같이 `기본 비트 표시는 바뀌지 않는다`는 규칙을 따른다.

1. 변환은 `명시적인 캐스팅`에 의해 발생할 수 있다.

   ``` c
   int tx, ty;
   unsigned ux, uy;
   
   tx = (int) ux;
   uy = (unsigned) ty;
   ```

2. 한 가지 타입의 수식이 **다른 타입의 변수에 할당**될 때 `묵시적`으로 발생할 수 있다.

   ``` c
   int tx, ty;
   unsigned ux, uy;
   
   tx = ux; /* 부호형으로 캐스트 */
   uy = ty; /* 비부호형으로 캐스트 */
   ```

3. 그 외

   - 숫자 값을 printf로 출력할 때

     : 디렉티브 %d, %u, %x는 수를 부호형 십진수, 비부호형 십진수, 16진수 형식으로 출력하기 위해 사용한다.

     > printf는 타입 정보를 활용하지 않는다.
     >
     > 그래서 int 타입의 값을 디렉티브 %u를 사용해서 출력할 수 있고, unsigned 타입의 값을 %d를 사용해서 출력할 수 있다.

     ``` c
     int x = -1;
     unsigned u = 2147483648; /* 2^31 */
     
     printf("x = %u = %d\n", x, x);
     printf("u = %u = %d\n", u, u);
     ```

     결과(`32비트 프로그램`으로 컴파일):

     ``` c
     x = 4294967295 = -1
     y = 2147483648 = -2147483648
     ```

**[산술연산]**

C는 **모든 정수 데이터 타입에 대해** 부호형과 비부호형 `산술연산`을 지원한다.

일반적으로 대부분의 수들은 기본적으로 `부호형`이다.

- 12345, 0x1A2B - 부호형 상수로 간주
- 12345`U`, 0x1A2B`u` - 비부호형 상수("U", "u" 추가)

C에서 비부호형과 부호형 값들이 섞여 있는 수식을 처리하는 방식

- C는 묵시적으로 **부호형 인자를 비부호형으로 변환**하여 계산한다.
  - 이러한 관습은 관계 연산(<, >)에 대해서 덜 직관적인 결과를 만든다.

<img src="images/02_comparison.jpg" style="zoom:70%;" />

### 6) 수의 비트 표시를 확장하기

값은 동일하게 유지한 채 다른 길이의 워드로 정수를 변환하는 것은 **일반적인 연산**의 하나이다.

보다 작은 길이에서 더 큰 길이의 자료형으로 변환하는 것은 언제나 가능해야 한다.

**법칙**

1. 비부호형 수를 `영의 확장(zero extension)`으로 확대하기

   : 앞에 0들을 추가한다. 

   w´ > w일 때, 길이 w의 비트 벡터 u = [u*w-1*, u*w-2*, . . . , u*0*]와 길이가 w´인 벡터 u´ = [**0, . . . , 0**, u*w-1*, u*w-2*, . . . , u*0*] 에 대해서 B2U*w*(u) = B2U*w´*(u´)가 성립한다.

   **유도**

   `비부호형 인코딩의 정의`로부터 곧바로 도출된다.

   <img src="images/02_B2U.JPG" style="zoom:80%;" />

2. 2의 보수를 `부호 확장(sign extension)`으로 확대하기

   : MSB를 복사해서 앞부분에 추가한다.

   w´ > w인 길이 w의 비트 벡터 x = [x*w-1*, x*w-2*, . . . , x*0*]와 길이가 w´인 벡터 x´ = [**x*w-1*, . . . , x*w-1***, x*w-1*, x*w-2*, . . . , x*0*] 에 대해서 B2T*w*(x) = B2T*w´*(x´)가 성립한다.

   **유도**

   증명은 **k에 대한 귀납법**으로 이루어진다.

   만일 부호 비트를 **1비트 확장**해도 숫자 값을 보존할 수 있다는 것을 증명할 수 있다면, 이 특성은 부호 비트를 임의의 길이로 늘리더라도 만족된다는 것이다.

   > 그래서 증명 과정을 다음과 같이 단순화할 수 있다.

   ​	B2T*`w+1`*([**x*w-1***, x*w-1*, x*w-2*, . . . , x*0*]) = B2T*w*([x*w-1*, x*w-2*, . . . , x*0*])

   위 식의 좌변을 B2T 함수의 정의대로 전개하면 도출된다.

   <img src="images/02_B2T.JPG" style="zoom:80%;" />
   
   - 사용한 주요 성질은 2^w - 2^(w-1) = 2^(w-1)

> C 표준은 short에서 unsigned로 변환하는 것처럼, **데이터 길이 변환**과 **비부호형과 부호형 사이에 변환**하는 작업을 동시에 하는 경우의 `순서`를 명시한다.
>
> - 프로그램이 먼저 크기를 바꾸고 다음에 자료형을 바꾼다.

### 7) 숫자의 절삭

w비트의 수를 k비트 수로 절삭할 때 **상위 w - k 비트를 제거**해서 새로운 비트 벡터를 얻는다.

**수를 절삭하면 값이 바뀔 수 있다.** 이것은 일종의 `오버플로우`와 같다.

``` c
int x = 53191; 
/* 00 00 cf c7 */
short sx = (short) x; /* -12345 */
/* cf c7 */
int y = sx; /* 수의 비트 표시를 다시 확장(2의 보수 => 부호 확장): -12345 */
/* ff ff cf c7 */
```

**법칙**

1. 비부호형 수의 절삭

   : 비트 벡터 x = [x*w-1*, x*w-2*, . . . , x*0*]를 k비트로 절삭한 결과를 x´ = [x*k-1*, x*k-2*, . . . , x*0*]이라고 하자.

   그리고 X = B2U*w*(x)이고, X´ = B2U*k*(x´)라고 하면,

   X´ = X mod 2^k 이다.

   - 삭제되는 모든 비트들은 i ≥ k인 2^i의 자리값을 가지며, 따라서 이 자리값들은 **모듈 계산으로 모두 0이 된다**.

   **유도**

   X´ = X mod 2^k 식 양변에 `비부호형 인코딩의 정의(함수 B2U)`를 적용해서 전개한다.

   - 사용한 특성은 i ≥ k인 모든 i에 대해 2^i mod 2^k = 0

2. 2의 보수 숫자의 절삭

   - MSB를 **부호 비트**로 바꾼 것을 제외하고는 비부호형에서와 유사한 특성이 성립한다.

     (2의 보수를 절삭해도 2의 보수여야 하므로, MSB부터 절삭한 후에 부호비트가 사라지므로 다시 부호비트를 고려해줘야 함)

   비트 벡터 x = [x*w-1*, x*w-2*, . . . , x*0*]를 k비트로 절삭한 결과를 x´ = [x*k-1*, x*k-2*, . . . , x*0*]이라고 하자.

   그리고 X = B2T*w*(x)이고, X´ = B2T*k*(x´)라고 하면,

   X´ = **U2T*k***(X mod 2^k) 이다.

   - X mod 2^k는 0과 2^k - 1 사이의 수를 갖는다. 여기에 함수 U2T*k*를 적용하면 MSB인 x*k-1*이 자리값 2^(k-1) 대신 - 2^(k-1)을 갖는 효과를 낸다.

   **유도**

   X mod 2^k는 

   B2T*w*([x*w-1*, x*w-2*, . . . , x*0*]) mod 2^k = ∑i=[0,k-1] x*i* * 2^i **(음수 weight를 갖는 MSB 항은 무조건 사라짐)**

   ​																= B2U*k*([x*k-1*, x*k-2*, . . . , x*0*]) **(양수항만 남았으므로 unsigned)**

   이것을 비트패턴은 유지한 채 `2의 보수`로 해석하면

   X´ = U2T*k*(X mod 2^k) 이 된다.

   - 사용한 특성은 i ≥ k인 모든 i에 대해 2^i mod 2^k = 0

### 8) Signed와 Unsigned에 관한 조언

묵시적 타입 변환의 미세한 효과로 인해서 생기는 버그들은 알아내기가 상당히 어렵다.

그 이유는 타입 변환이 코드 내에서 명확한 표시 없이 발생하기 때문이다.

> 이러한 버그들을 피하는 한 가지 방법은 **비부호형 수를 절대로 사용하지 않는 것**이다.
>
> 실제로 C와 C++ 외의 다른 언어들은 unsigned 정수를 지원하지 않는다.
>
> - 자바는 signed 정수만을 지원하며, 2의 보수 산술연산으로 구현될 것을 요구한다.
>   - \>> : 산술 우측 쉬프트 (좌측 끝을 MSB로 채움)
>   - \>>> : 논리 우측 쉬프트 (좌측 끝을 0으로 채움)

비부호형 값들은 `워드 길이 데이터`를 숫자 값으로 해석하지 않고 단지 **비트들의 집합**으로 생각하려는 경우에 매우 유용하다.

- 플래그들로 한 개의 워드를 압축할 때
  - 여러 가지 부울 조건들을 설명하는 플래그들
- 주소
  - 주소는 본래 unsigned여서 **시스템 프로그래머**들에게 유용함
- 숫자들이 워드의 배열로 표시되는 경우에 수학 패키지로 구현할 때
  - modular 연산
  - 다중정밀도 산술연산



## 3. 정수의 산술연산

컴퓨터 산술연산의 **유한한 본성**에 의해 생겨난 미묘한 결과들이 존재한다.

### 1) 비부호형 덧셈

- "워드 크기 증가" 문제

  : 두 개의 비음수 x, y (0 ≤ x, y ≤ 2^w)가 있다고 하자. 이들 각각은 `w비트 비부호형 수`로 표시될 수 있다.

  그러나 이들의 합을 계산하면 가능한 범위는 0 ≤ x + y ≤ 2^(w+1) - 2를 갖는다. 이 합을 표시하기 위해서는 **w+1개의 비트**가 필요하게 된다.

  만일 이 x+y 합에 다른 값을 더하려 한다면, **w+2비트**가 필요하다.

  => 이와 같이 산술연산의 결과를 완벽하게 표시하려면 필요한 `워드 크기`를 제한할 수 없다.

  - 일부 프로그래밍 언어들은 임의의 크기(컴퓨터의 메모리 제한 범위 내에서)를 갖는 산술연산을 지원한다.
    - Lisp

  > 일반적으로 프로그래밍 언어들은 **고정길이 산술연산**을 지원하며
  >
  > 따라서 "덧셈"과 "곱셈" 같은 연산은 정수에 대응하는 일반적인 연산들과는 다르다.

**법칙**

- 비부호형 덧셈

  : 0 ≤ x, y < 2^w인 변수 x, y에 대해 x + y 정수합을 **w비트 길이로 절삭한 후에 다시 비부호형 정수로 나타내는** 연산으로 `정의`한다.

  - 비부호형 산술연산은 **나머지 연산(modular)**의 한 가지 형태로 *볼 수 있으며*,

  - x + y의 `비트수준 표현`에서 자리값이 2^(w-1)보다 큰 비트들을 단순히 삭제한다.

    (= x + y의 `비부호형 정수 표현`을 2^w로 나눈 나머지를 구한다.)

    - ex) x = 9, y = 12, w = 4일 때,

      x + y = [1001] + [1100] = [`1`0101] (5비트)  --> [0101] (4비트) = 5

      이것은 21 mod 16 = 5와 일치한다.

  <img src="images/02_plus_unsigned.JPG" style="zoom:80%;" />

  - `오버플로우`의 경우에는 2^w만큼 줄어드는 효과를 낸다.

  **유도**

  - x + y < 2^w인 경우 합을 w+1비트로 표현할 때, 맨 앞의 비트는 0이 되어서 이 비트를 버려도 값의 변동이 없다.
  - 2^w ≤ x + y < 2^(w+1)인 경우 합을 w+1비트로 표현할 때, 맨 앞의 비트는 1이 되어서 이 비트를 버리면 2^w를 뺀 것과 같아진다.

산술연산에서 완전한 정수 결과가 그 데이터 타입의 제한된 워드 길이로 나타낼 수 없을 때, 이 연산은 "오버플로우한다"고 한다.

> C 프로그램 실행 시 오버플로우는 에러로 표시하지 않는다.

- 비부호형 덧셈에서 오버플로우 검출하기

  : 0 ≤ x, y ≤ UMax*w*인 x, y에 대해서 s = x + y (비부호형 덧셈)라고 정의하자.

  오직 s < x인 경우 또는 s < y인 경우에만 s의 계산결과가 오버플로우한다.

  **유도**

  - s = x + y ≥ x라는 점에 주목하면, s가 오버플로우하지 않았다면, 당연히 s ≥ x.

  - s가 오버플로우되었다면, s = x + **y - 2^w**가 된다.

    y < 2^w이기 때문에 **y - 2^w < 0**이며, 따라서 s = x +(y - 2^w) < x이다.



Modular 덧셈은 `아벨 그룹(abelian group)`이라고 알려진 수학적 구조를 형성한다.

- `군(group)`은 연산에 대해 닫혀있고, **항등원**과 **역원**이 존재하며, **결합법칙**이 성립하는 집합과 연산이다. 

  여기에 추가로 **교환법칙**까지 성립하는 군을 `아벨군`이라고 한다.

- Modular 덧셈은 항등원(identity) 0을 가지며, 모든 원소는 덧셈의 역(inverse)을 가진다.

w비트 비부호형 산술연산을 **나머지 연산(modular)**의 한 가지 형태로 보는 관점을 연장하려면, 역을 반드시 정의해야 한다. (그리고 추가로 결합법칙, 교환법칙이 성립함을 증명하면 된다)

- 이 관점을 연장할 때 좋은 점은 아벨 군의 여러가지 증명된 성질을 사용할 수 있다는 점이다.

**법칙**

- 비부호형 비트반전(negation)

  : 0 ≤ x, y < 2^w인 모든 x에 대해서, x의 w비트 비부호형 비트반전 연산 -x는 다음과 같이 `정의`된다.

  <img src="images/02_negation_unsigned.JPG" style="zoom:80%;" />

  **유도**

  - x = 0일 때, 덧셈의 `역`은 당연히 0이다.

  - x > 0일 때, 0 < **2^w - x** < 2^w의 범위에 있다.(∵UMax*w* = 2^w - 1) 즉, 이 값은 `w비트 부호형 수의 집합`에 포함된다.

    (x + **2^w - x**) mod 2^w = 2^w mod 2^w = 0 이므로

    **2^w - x**이 +(비부호형 덧셈)에 대한 x의 `역`이 된다.

### 2) 2의 보수의 덧셈

정수 x, y가 - 2^(w-1) ≤ x, y ≤ 2^(w-1) - 1 범위의 값을 가질 때, 이들의 합은 - 2^w ≤ x, y ≤ 2^w - 2 범위에 있게 되어서 정확히 표시하려면 **w+1 비트**가 필요할 수 있다.

**법칙**

- 2의 보수의 덧셈

  : - 2^(w-1) ≤ x, y ≤ 2^(w-1) - 1인 변수 x, y에 대해 x + y 정수합을 **w+1비트 표현으로 나타낸 결과를, w비트 길이로 절삭한 후에 다시 2의 보수형 정수로 나타내는** 연산으로 `정의`한다.

  > 아래 식은 오버플로우가 발생한 경우들을 구별할 수 있도록 해준다.

  <img src="images/02_plus_signed.JPG" style="zoom:80%;" />

  *TMax = 2^(w-1) - 1, TMin = - 2^(w-1)*

  > 두 개의 w비트 2의 보수 합은 비부호형 합과 정확히 **동일한 비트수준 표시**를 갖는다.
  >
  > 사실 대부분의 컴퓨터는 비부호형이건 부호형 덧셈이건 **동일한 기계어 인스트럭션**을 사용한다.

  **유도**

  **2의 보수 덧셈이 비부호형 덧셈과 동일한 `비트 표현`을 가지므로 +(u,w) 연산을 이용하여 +(t,w) 연산의 `정수 표현`에 대한 정의를 할 수 있다.**-`비트 표현`에 대한 정의는 두 연산 모두 단순한 bitwise 연산이다

  +(t,w) 연산은 인자를 비부호형으로 변환하고, 비부호형 덧셈을 수행한 후에 다시 2의 보수로 변환한 것으로 볼 수 있다.

  ​	x +(t,w) y = U2T*w*(T2U*w*(x) +(u,w) T2U*w*(y))

  `함수 T2U의 정의`에 의해 위의 식을 전개하면

  ​	x +(t,w) y = U2T*w*((x*w-1*\*2^w + x) +(u,w) (y*w-1*\*2^w + y)) **(T~U 차이는 0 또는 2^w)**

  ​					 = U2T*w*((x*w-1*\*2^w + x + y*w-1*\*2^w + y) mod 2^w) **(∵+(u,w)는 modular 덧셈)**

  ​					 = U2T*w*((x+y) mod 2^w) **(T~U 차이가 2^w인 경우 항 사라짐. 따라서 x+y는 음수가 될 수 있다)**

  ​					 = U2T*w*(z´) **(x + y의 w+1번째 캐리비트가 절삭됨)**

  ​	ex) -8 `+(t,4)` -5 = U2T*4*((1*2^4 + -8) `+(u,4)` (1\*2^4 + -5))

  ​								= U2T*4*((1*2^4 + -8 + 1\*2^4 + -5) mod 2^4)

  ​								= U2T*4*((-8 + -5) mod 2^4) 

  ​		(여기서 -13 = [10011]은 비트패턴 2의 보수 덧셈연산을 정의해서 쓴 것이 아니라, 단순히 -13 정수의 2의 보수 비트표현이다)

  ​								= U2T4(3) (w+1번째 캐리비트가 절삭됨. w+1번째 캐리비트 weight 더해주기; -13+`2^4` = 3)

  ​								= 3 (비음수 범위에서는 U=T)

  - z = x + y (x + y의 `w+1번째 캐리비트`가 절삭되기 전의 정수값)

  - z´ = z mod 2^w (x + y의 `w+1번째 캐리비트`가 절삭된 후의 정수값)

  - z´´ = U2T*w*(z´) = x +(t,w) y

  - Case 1. 음의 오버플로우

    - -2^w ≤ z < - 2^(w-1) **[w+1 비트로 표현 가능한 범위]**

    - z는 음수이므로 `2의 보수 비트표현`에서 MSB가 1이다. mod 연산으로 w+1비트 길이 워드의 MSB가 0이 되므로 z´ = z + 2^w이다.

    - 0 ≤ z´< 2^(w-1)이고, 이 범위는 ≤ TMax*w*를 만족하므로 T = U이다. 

      즉, z´´ = U2T*w*(z´) = z´ = z + 2^w이다.

     => 두 음수 x와 y를 더하여(x + y < - 2^(w-1)이기 위해서는 최소한 x, y가 모두 음수여야 함) 비음수 결과 x + y + 2^w를 얻었다.

  - Case 2. 

    - -2^(w-1) ≤ z < 0 **[w 비트로 표현 가능한 범위지만, w+1 비트로 표현해야 함-`정의`에 의해?]**

      ex) w = 4일 때, x + y = -3이라면 -3 = [11101]로 5비트로 표현해야 한다.

    - Case 1.과 같은 이유로 z´ = z + 2^w이다.

    - 2^(w-1) ≤ z´< 2^w이고, 이 범위는 > TMax*w*를 만족하므로 T = U - 2^w이다.

      즉, z´´ = U2T*w*(z´) = z´- 2^w = z이다.

    => 2의 보수 합 z´´은 정수 합 x + y와 같다.

  - Case 3.

    - 0 ≤ z < 2^(w-1) **[w 비트로 표현 가능한 범위지만, w+1 비트로 표현해야 함-`정의`에 의해?]**

      ex) w = 4일 때, x + y = 7이라면 7 = [00111]로 5비트로 표현해야 한다.

    - z는 양수이므로 `2의 보수 비트표현`에서 MSB가 0이다. mod 연산으로 w+1비트 길이 워드의 MSB가 0이 되므로 값의 변동이 없어서 z´ = z이다.

    - 0 ≤ z´< 2^(w-1)이고, 이 범위는 ≤ TMax*w*를 만족하므로 T = U이다.

      즉, z´´ = U2T*w*(z´) = z´ = z이다.

    => 2의 보수 합 z´´은 정수 합 x + y와 같다.

  - Case 4. 양의 오버플로우

    - 2^(w-1) ≤ z < 2^w **[w+1 비트로 표현 가능한 범위]**

    - z는 양수이므로 `2의 보수 비트표현`에서 MSB가 0이다. mod 연산으로 w+1비트 길이 워드의 MSB가 0이 되므로 값의 변동이 없어서 z´ = z이다.

    - 2^(w-1) ≤ z´ < 2^w이고, 이 범위는 > TMax*w*를 만족하므로 T = U - 2^w이다. 

      즉, z´´ = U2T*w*(z´) = z´- 2^w = z - 2^w이다.

     => 두 양수 x와 y를 더하여(x + y ≥ 2^(w-1)이기 위해서는 최소한 x, y가 모두 양수여야 함) 음수 결과 x + y - 2^w를 얻었다.

> 음의 오버플로우가 발생하면 정수합보다 2^w이 더 큰 결과를 만든다는 점과, 양의 오버플로우는 2^w 적은 결과를 만든다는 점에 유의하라.

- w비트 2의 보수합의 `비트수준 표시`는 오퍼랜드들을 이진수로 덧셈한 후에 그 결과를 **w비트로 절삭**하여 얻을 수 있다.

<img src="images/02_plus_signed_example.jpg" style="zoom:50%;" />

- 2의 보수 덧셈에서 오버플로우의 감지

  : TMin*w* ≤ x, y ≤ TMax*w*인 x, y에 대해서, s = x +(t, w) y라고 정의하자.

  - s의 계산은 x > 0, y > 0, s ≤ 0인 경우에만 `양의 오버플로우`가 발생했다.
  - x < 0, y < 0, s ≥ 0인 경우에만 `음의 오버플로우`가 발생했다.

  **유도**

  먼저 양의 오버플로우 여부를 분석해보자.

  - 만일 x > 0, y > 0, s ≤ 0인 경우라면 당연히 양의 오버플로우가 발생할 것이다. (두 양수 정수의 합이 음수가 되었으므로)
  - 역: 양의 오버플로우가 발생하려면 x > 0, y > 0(그렇지 않다면 x + y < TMax*w*가 된다), 그리고 s ≤ 0이어야 한다. (∵+(t, w) 정의식에 의해)

  유사한 분석을 음의 오버플로우에 대해서도 할 수 있다.

### 3) 2의 보수에서의 비트반전(Negation)

TMin*w* ≤ x ≤ TMax*w*인 모든 x에 대해서, 이에 대응하는 `2의 보수 비트반전 연산`은 다음과 같은 수식으로 구할 수 있다.

<img src="images/02_negation_signed.JPG" style="zoom:80%;" />

- w비트 2의 보수 덧셈에 대해, TMin*w*는 자기 자신의 덧셈에 대한 역이며,
- 다른 x값에 대해서는 -x가 덧셈에 대한 역이다.

**유도**

- TMin*w* + TMin*w* = - 2^(w-1) + - 2^(w-1) = - 2^w

  이 식은 음의 오버플로우를 발생시키며, 따라서 TMin*w* +(t,w) TMin*w* = - 2^w + 2^w = 0.

- TMin*w*은 2의 보수의 **범위의 비대칭성** 때문에 대응하는 -x인 -TMin*w*를 w비트 2의 보수로 표시할 수 없었다.  

  하지만 TMin*w* 외에 다른 값들은, 대응하는 -x를 w비트 2의 보수로 표시할 수 있다.

  따라서 -x + x = 0이다.

``` c
위 식은 2의 보수 비트반전의 정수수준 표현이다.
*2의 보수 비트반전의 비트수준 표현
: 비트수준으로 표현된 값의 2의 보수 비트반전 값을 구하는 여러 가지 기발한 방법이 있다.
    1) 비트들을 반전시킨 뒤에 그 결과를 1 증가시킨다.
      C에서 어떤 정수 값에 대해 -x와 ~x+1을 계산하면 동일한 결과를 얻는다.
    	ex) 디버깅할 때 0xfffffffa 값을 만나면 MSB = 1이므로 ~x+1을 해보자.
    		0x00000005 + 1 = 0x00000006. 따라서 이 값은 -6의 2의 보수이다.
    2) 비트 벡터를 두 부분으로 나누는 방법
      k가 가장 우측에 1이 나오는 위치를 표시한다고 하면, 
	  x(x ≠ 0)의 비트수준 표시는 [xw-1, xw-2, ... , xk+1, 1, 0, ... , 0]의 형태를 갖는다.
      이 때, 각 비트를 k의 왼쪽까지 반전시키면 비트반전이 된다.
      [~xw-1, ~xw-2, ... , ~xk+1, 1, 0, ... , 0]
      	ex) -4 = [1100]의 비트 반전은 [0100] = 4
          	-8 = [1000]의 비트 반전은 [1000] = -8
 두 경우 모두 TMin = -8 = [1000]의 2의 보수 비트반전은 TMin의 결과가 나온다.  
```

### 4) 비부호형 곱셈

범위 0 ≤ x, y < 2^w - 1을 갖는 정수 x, y는 `w비트 비부호형 수`로 나타낼 수 있지만, 

이들의 곱 x*y는 0 ≤ x\*y < (2^w - 1)^2 = 2^(2w) - 2^(w+1) + 1 범위를 갖는다.

이것을 표시하려면 최대 **2w 비트**가 필요하다.

**법칙**

- 비부호형 곱셈

  > C언어에서 비부호형 곱셈은 **2w비트 정수 곱의 하위 w비트로 주어지는 w비트 값을 만드는 것**으로 `정의`된다.

  - `비부호형 수`를 w비트로 **절삭**하는 것은 해당 값을 2^w로 나눈 나머지를 계산하는 것과 같다.
    **=> 곱한 정수값을 비부호형 절삭 공식에 대입하면 된다.**

  - 0 ≤ x, y ≤ UMax*w*인 x, y에 대해서

    <img src="images/02_multiplication_unsigned.JPG" style="zoom:80%;" />

### 5) 2의 보수 곱셈

범위 - 2^(w-1) ≤ x, y < 2^(w-1) - 1을 갖는 정수 x, y는 `w비트 2의 보수`로 나타낼 수 있지만, 

이들의 곱 x*y는 - 2^(w-1) * (2^(w-1) - 1) = - 2^(2w-2) + 2^(w-1)과 - 2^(w-1) * - 2^(w-1) = 2^(2w-2) 사이의 범위를 갖는다.

이것을 2의 보수 형태로 나타내려면 최대 **2w 비트**가 필요하다.

**법칙**

- 2의 보수 곱셈

  > C언어에서 부호형 곱셈은 일반적으로 **2w비트를 w비트로 절삭하는 형태**로 실행한다.

  - `2의 보수`를 w비트로 **절삭**하는 것은, 먼저 그 값을 2^w로 나눈 나머지를 취하고, 비부호형에서 2의 보수형태로 변환하는 것과 같다.

    **=> 곱한 정수값을 2의 보수형 절삭 공식에 대입하면 된다.**

  - TMin*w* ≤ x, y ≤ TMax*w*인 x, y에 대해서

    <img src="images/02_multiplication_signed.JPG" style="zoom:80%;" />

> 곱셈 연산을 `비트수준`으로 표시하는 것은 비부호형이나 부호형 곱셈에서 모두 **동일하다**.

- 비부호형과 2의 보수 곱셈의 비트수준 동일성

  - X, Y : 길이 w인 비트벡터
  - 정수 x, y: 각 비트벡터를 2의 보수로 표시한 값
    - x = B2T*w*(X), y = B2T*w*(Y)
  - 음수가 아닌 정수 x´, y´: 각 비트벡터를 비부호형으로 나타낸 값
    - x´= B2U*w*(X), y´= B2U*w*(Y)

  그러면 다음과 같은 관계가 성립한다.

  ​	T2B*w*(x \*(t,w) y) = U2B*w*(x´ *(u,w) y´)

  > 비부호형의 절삭한 곱은 항상 x*y mod 2^w과 같다.
  >
  > 절삭한 곱의 `비트 수준 표시`는 비부호형과 2의 보수 곱셈에서 모두 동일하므로, x\*y mod 2^w라는 간단한 공식을 2의 보수 곱셈 값을 계산할 때에도 사용할 수 있다. T = U2T*w*(x\*y mod 2^w)
  >
  > - **이것은 이 두 곱의 완전한 2w비트 표시가 다를지라도 그러하다.**

  **유도**

  `함수 T2U`의 정의로부터 x´= x + x*w-1*\*2^w, y´= y + y*w-1*\*2^w이다. (T~U 사이의 차이는 0 또는 2^w)



### 8) 정수 산술연산에 대한 마지막 고찰

> 살펴본 것처럼 컴퓨터에서 실행되는 `"정수" 산술연산`은 실제로는 `modular 산술연산`의 형태로 수행된다.

또한, `2의 보수 표현 방식`이 **비부호형 `산술연산`에서 사용된 것과 동일한 비트수준 구현**을 사용하면서 음수와 양수 값을 효과적으로 표현할 수 있는 방법이라는 것을 알 수 있다.

- 덧셈, 뺄셈, 곱셈, 나눗셈 모두 오퍼랜드가 2의 보수이건 비부호형이건 **동일하거나 매우 유사한 비트수준 동작**을 갖는다.

C의 일부 관습들이 이해하기 어려운 버그들의 원인이 될 수 있다.

- unsigned 자료형의 예시
  - 정수 상수를 쓸 때
  - 라이브러리 루틴을 호출할 때