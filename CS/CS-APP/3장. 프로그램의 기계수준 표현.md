> # Part 1: 프로그램의 구조와 실행
>
> 컴퓨터 시스템에 대한 탐구는 프로세서와 메모리 서브시스템으로 구성된 컴퓨터 자체를 공부하는 것으로 시작한다.
>
> - 응용 프로그램이 어떻게 표시되고 실행되는지에 대한 깊은 이해를 할 수 있게 된다.
> - 안전하고 안정적인 프로그램을 작성하고, 컴퓨팅 자원을 가장 잘 사용할 수 있도록 하는 기법을 배운다.

# 3장. 프로그램의 기계수준 표현

컴퓨터는 `인코딩`한 연속된 바이트인 **기계어 코드(machine code)를 실행**한다.

컴파일러는 프로그램 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 **기계어 코드를 생성**한다.

1. GCC `C 컴파일러`는 기게어 코드를 문자로 표시한 **어셈블리 코드**의 형태로 출력을 만들어 **프로그램의 각 인스트럭션을 만들어 낸다**.
2. 그리고 나서, GCC는 `어셈블러`와 `링커`를 호출하여 어셈블리 코드로부터 실행 가능한 **기계어 코드**를 생성한다.

컴파일러에서는 **타입체크 기능**을 제공한다.

- 프로그램 에러를 검출하는 데 도움을 준다.
- 데이터를 균일하게 참조하고 처리하는 일을 정확히 할 수 있도록 도와준다.

최신 최적화 컴파일러가 만들어 낸 코드는 대부분 잘 훈련된 어셈블리어 프로그래머가 작성한 것과 유사한 효율성을 갖는다.

> 그럼에도 우리가 기계어 코드를 배워야 하는 이유는, 
>
> 컴파일러가 만들어 내는 어셈블리 코드들을 읽고 이해하는 기술은 진정한 프로그래머들에게 매우 중요한 기술이기 때문이다.
>
> - 컴파일러를 적절한 커맨드라인 인자와 함께 호출하면 `어셈블리 코드 형태의 파일`로 출력을 생성한다.
>
> - 이 코드를 이해하면 **컴파일러의 최적화 성능**을 알 수 있으며, **코드에 내재된 비효율성**을 분석할 수도 있다.
>
>   - 고급 언어에서 제공하는 추상화 계층 때문에 이해가 필요한 프로그램의 **런타임 동작**이 감춰지는 경우
>   - 악성 프로그램의 공격 방법 중 상당수가 프로그램이 런타임 제어 정보를 저장하는 방식의 미묘한 차이와 관련 있음 
>
>   => 런타임 동작의 정보는 기계어 코드 수준에서 알 수 있다.

**목표**

- C, 어셈블리 코드, 기계어 코드 간의 관계

  - 이 장에서는 한 개의 특정 어셈블리어(`x86-64`)를 배우고, C 프로그램이 어떻게 이들 기계어 코드 형태로 컴파일 되는지 공부한다.

  - 이것은 `역엔지니어링(reverse engineering)`의 일종이다.

    - 역엔지니어링

      : 시스템이 만들어진 과정을 연구하고 역방향으로 분석하여 이해하려는 작업

- x86-64의 세부 사항들

  : 이 기계어는 요즘 사용하는 대부분의 컴퓨터 뿐만 아니라 대규모 데이터 센터나 슈퍼컴퓨터에서도 이용된다.

  - 데이터의 표현과 처리
  - 제어의 구현
    - C언어에서의 제어 구조인 if, while, switch문들이 어떻게 구현되어 있는지

- 프로시저의 구현

  - 지역변수와 프로시저 간에 데이터와 제어를 전달하기 위한 `런타임 스택`을 프로그램이 어떻게 관리하는지

- 배열, 구조체, 유니온 같은 자료구조들이 기계수준에서 어떻게 구현되었는지

  - out-of-bound 메모리 참조 문제
  - 버퍼 오버플로우 공격에 대한 시스템 취약성

- 부동소수점 데이터와 연산과 관련된 코드의 기계어 표현



컴퓨터 업체들은 최근에 32비트에서 64비트 머신으로 전환했다.

- 32비트 컴퓨터 - **4 GB (2^32)**의 램만 사용 가능
- 64비트 컴퓨터 - 최대 **256 TB (2^48)**의 램 사용 가능. 쉽게 16 엑사바이트(2^64)까지도 확장될 수 있다.

> x86-64 프로세서들의 기능 중에서 GCC와 리눅스에서 사용하는 일부분의 기능들만 다루고자 한다.
>
> 아래의 복잡하고 불가사의한 부분들은 대부분 피할 것이다.
>
> - 초창기 16비트 마이크로프로세서 시절의 레거시를 지원하기 위한 x86-64의 많은 기능들
>
> - 대부분의 개발을 인텔이 주도하였지만, 경쟁사인 AMD(Advanced Micro Devices)도 중요한 기여를 해왔기 때문에 다소 기형적인 설계를 가지게 됨

``` c
*IA32(Intel Architecture 32-bit) 프로그래밍
: x86-64의 전 버전인 IA32는 인텔사에 의해 1985년 소개되었다.
 요즘 판매되는 대부분의 x86 마이크로프로세서와 이들 머신에 설치된 대부분의 운영체제는 x86-64를 실행하기 위해 설계된다.
 그렇지만, 이들은 '역방향 호환성 모드' 때문에 IA32 프로그램들도 실행할 수 있다.
 그 결과로 많은 응용 프로그램들은 여전히 IA32에 기초하고 있다.
```

## 1. 역사적 관점

`x86`이라고 통칭하는 **인텔 프로세서 제품군**은 오랜 기간 진화를 통한 개발을 해 왔다.

- 8086 (1978, 29 K 트랜지스터)

  : 이 제품들은 **최초의 단일칩 `16비트` 마이크로프로세서**로 출발했다.

  - 8087 부동소수점 보조 프로세서(1980, 45 K 트랜지스터)

    : 8086이나 8088과 함께 사용하며 `부동소수점 인스트럭션`을 실행하였다.

    8087은 x86 제품군을 위한 부동소수점 모델을 정립하였으며, "`x87`"이라고 불렸다.

- i386 (1985, 275 K 트랜지스터)

  : 구조를 32비트로 확장. 리눅스와 최신 윈도우 운영체제에서 사용하는 `선형 주소모델` 추가

  **유닉스 운영체제를 완벽하게 지원할 수 있는 최초의 컴퓨터**

- 펜티엄 시리즈 (1993 ~ 2004)

  - 펜티엄 4E (2004, 125 M 트랜지스터)

    - `하이퍼쓰레딩(hyperthreading)` 기법의 추가

      : 두 개의 프로그램을 하나의 프로세서에서 동시에 실행할 수 있는 기법

    - AMD사에서 개발한 IA32의 64비트 확장 구현인 EM64T 추가

      => 이를 `x86-64`라고도 한다.

- Core 시리즈 (2006 ~ 2013)

  - Core2 (2006, 291 M 트랜지스터)

    : P6와 유사한 마이크로 구조로 복귀.

    한 개의 칩 내에 멀티 프로세서를 구현한 **최초의 `멀티코어` 인텔 마이크로프로세서**

    멀티코어를 지원하는 대신 `하이퍼쓰레딩`을 지원하지 않음

    - 이후의 Core i7, Nehalem (2008, 781 M 트랜지스터)부터는 멀티코어와 하이퍼쓰레딩을 함께 지원한다.

> - 초기 8086과 그 확장형인 80286에서 사용하는 메모리 모델은 i386에서는 더 이상 사용되지 않는다.
> - 오리지날 x87 부동소수점 인스트럭션들은 SSE2가 도입되면서부터는 사용하지 않게 되었다.

각각의 인접한 프로세서는 이전 버전과 **호환성**을 갖도록 설계되었다.

따라서 인스트럭션 집합에는 이러한 진화적인 유산 때문에 많은 이상한 잔재기능들이 존재한다.

- x86

  : x86-64, Intel64 라고도 부른다.

  Intel64는 IA32의 64비트 확장형이라는 의미로 붙여진 이름이다.

> 비록 이 책에서는 인텔 프로세서들에 대해서만 다루겠지만, 본문 내용은 인텔의 경쟁사가 만든 **호환성이 있는 프로세서**들에도 동일하게 적용된다. 



## 2. 프로그램의 인코딩

C 프로그램을 두 개의 파일 p1.c와 p2.c에 작성한다고 하자.

이 코드를 유닉스 커맨드 라인으로 다음과 같이 컴파일 한다:

``` shell
linux> gcc -0g -o p p1.c p2.c
```

- 명령어는 GCC의 `C 컴파일러`를 지정한다.

  (GCC C 컴파일러가 `리눅스에서 기본 컴파일러`이기 때문에 간단히 cc로 호출할 수도 있다)

- 커맨드 라인 옵션 -0g 

  : 공부를 위해서 본래 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 `최적화 수준`을 적용

  - GCC 4.8 버전 이상부터 사용 가능한 최적화 수준이다.

일반적으로 최적화 수준을 올리게 되면 최종 프로그램은 더 빨리 동작하게 되지만, 컴파일 시간이 증가하고, 디버깅 도구를 실행하기가 어려워질 위험이 있다.

**gcc** 명령은 `소스 코드`를 `실행 코드`로 변환하기 위해 일련의 프로그램들을 호출한다.

1. C 전처리기

   - #include로 명시된 파일을 코드에 삽입
   - #define으로 선언된 `매크로`를 확장

2. 컴파일러

   : 두 개의 소스파일의 `어셈블리` 버전인 p1.s와 p2.s를 생성

3. 어셈블러

   : 어셈블리 코드를 `바이너리 목적코드`인 p1.s와 p2.s를 생성

   - 목적코드는 **기계어 코드의 한 유형**이다

     ; 모든 인스트럭션의 바이너리 표현을 포함하고 있지만 **전역 값들의 주소는 아직 채워지지 않았다**.

4. 링커

   : 두 개의 목적코드 파일을 `라이브러리 함수`들을 구현한 코드와 함께 합쳐서 `최종 실행파일`인 p를 생성한다.

   (명령줄 디렉티브 -o p)

   - 실행 코드는 **기계어 코드의 두 번째 유형**이다

     ; 실행 코드는 **프로세서가 실행할 정확한 코드의 형태**이다.

### 1) 기계수준 코드

컴퓨터 시스템은 보다 간단한 `추상화 모델`을 이용해서 세부 구현내용을 감추면서 추상화의 여러 가지 다른 형태를 사용하고 있다.

이들 중에 두 가지 **추상화**가 기계수준 프로그래밍에서 특히 중요하다.

1. ISA (인스트럭션 집합구조, Instruction set architecture)

   : 기계수준 프로그램의 **형식**과 **동작**은 `ISA`에 의해 정의된다.

   ISA는 `프로세서의 상태`, `인스트럭션의 형식`, `프로세서 상태에 대한 각 인스트럭션들의 영향들`을 정의한다.

   - ISA는 실제 **프로세서 하드웨어의 추상화**를 제공한다. 

     이러한 추상화로 인해 기계어 코드 프로그램은 마치 한 번에 하나의 인스트럭션을 실행하는 프로세서에서 실행되는 것처럼 동작한다.

   - (x86-64 포함) 대부분의 ISA는 마치 하나의 인스트럭션이 다음 인스트럭션의 실행 전에 완료되는 `순차적인 실행`을 하는 것처럼 프로그램의 동작을 설명한다.

     프로세서 하드웨어는 훨씬 정교해서 여러 인스트럭션을 동시에 실행하지만, `ISA에 의한 순차적 동작`과 일치하는 전체 동작을 보이도록 해주는 **안전장치**를 사용한다.

   - 위와 같이 동일한 실행모델(=순차적인 모델)을 유지하기 때문에, **다른 프로세서에 구현될 때도 동일한 기계어 코드를 실행할 수 있게 된다**.

     - 하지만 그 비용과 성능의 범위는 다양하다. 

2. 가상주소

   : 기계수준 프로그램이 사용하는 주소는 `가상주소`이며, 메모리가 **매우 큰 바이트 배열**인 것처럼 보이게 하는 메모리 모델을 제공한다.

   실제 메모리 시스템은 여러 개의 메모리 하드웨어와 운영체제 소프트웨어로 구현되어 있다.

`컴파일러`는 C에서 제공하는 추상화된 실행모델로 표현된 프로그램을, 프로세서가 실행하는 인스트럭션들로 변환하는 대부분의 일을 수행한다.

- 어셈블리 코드 - 텍스트 형식. 더 읽기 쉽다.

- 기계어 코드 - 바이너리 형식

x86-64를 위한 기계어 코드는 C 코드와 달리 `프로세서의 상태`를 명시한다:

- 프로그램 카운터(PC, x86-64에서는 %rip라고 함)

  : 실행할 다음 인스트럭션의 메모리 주소를 가리킨다.

- 정수 레지스터 파일

  : `64비트 값`을 저장하기 위한 **16개의 이름을 붙인 위치**를 갖는다.

  이들 레지스터는 **주소**(C언어의 포인터에 해당하는)나 **정수 데이터**를 저장할 수 있다.

  - 일부 레지스터는 프로그램의 중요한 `상태`를 추적하는 데 사용
  - 다른 레지스터들은 함수의 `리턴 값`, 프로시저의 `지역변수`와 `인자` 같은 임시 값을 저장

- 조건코드 레지스터

  : **가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 `상태 정보`**를 저장한다.

  이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다.

- 벡터 레지스터

  : 벡터 레지스터들의 집합은 `하나 이상의 정수`나 `부동소수점 값`들을 각각 저장할 수 있다.

C가 다른 종류의 `데이터 타입`을 **선언**하고 **메모리에 할당**할 수 있는 모델을 제공하는 반면, 기계어 코드는 메모리를 단순히 `바이트 주소지정이 가능한 큰 배열`로 본다. (1byte 단위로 가상주소 할당하기가 가능함)

- 기계어 코드에서는 C에서 배열과 구조체 같은 연결된 데이터 타입들은 **연속된 바이트들**로 표시된다.
- 어셈블리 코드는 스칼라(scalar) 데이터 타입-단 하나의 값만을 저장할 수 있는 데이터 타입-의 경우에도 데이터 타입들 사이를 전혀 구분하지 않는다.
  - 부호형과 비부호형
  - 포인터와 정수형 사이 등

**[프로그램 메모리(가상메모리)]**

- 프로그램의 실행 기계어 `코드`, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 `런타임 스택`, 사용자에 의해 할당된(ex. malloc 라이브러리 함수) 메모리 블록들을 포함하고 있다.
- 가상주소의 일부 제한된 영역만이 `유효`하다.
  - x86-64 가상주소들은 **64비트 워드**들로 표현된다.
  - 현재(책 출시 당시) x86-64 기계들의 구현은 상위 16비트는 0으로 지정되어야 하고, 따라서 주소는 2^48 B = 256 TB 범위까지의 메모리를 이용할 수 있으며, 그 이상은 16엑사바이트(2^64 B)까지도 쉽게 확장될 수 있다.
  - 하지만 전형적인 프로그램들은 오직 몇 MB 혹은 몇 GB에 접근할 것이다.

> **운영체제**는 이 가상 주소공간을 **관리**해서 가상주소를 실제 프로세서 메모리 상의 **물리적 주소 값으로 번역**해준다.

하나의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다.

`컴파일러`는 **일련의 인스트럭션을 생성**해서 산술연산식의 계산, 반복문, 프로시저 호출과 리턴 등의 프로그램 구문을 구현해야 한다.

### 2) 코드 예제

다음과 같은 **프로시저 정의**를 포함하고 있는 C 코드 파일 mstore.c를 작성한다.

``` c
long mult2(long, long);

void multstore(long x, long y, long* dest){
    long t = mult2(x, y);
    *dest = t;
}
```

C 컴파일러가 생성한 **어셈블리 코드**를 보기 위해서 명령줄에서 -S 옵션을 사용할 수 있다.

- 이것은 컴파일러를 실행해서 어셈블리 파일 mstore`.s`를 만들고, 더 이상 진행하지 않는다.

``` shell
linux> gcc -0g -S mstore.c
```

``` c
*지속적으로 변하는 생성된 코드의 형태
 : 다른 컴파일러나 다른 버전의 GCC를 사용하면 다른 코드를 생성한다.
  GCC를 지원하는 오픈소스 커뮤니티는 '마이크로프로세서 생산업체에서 제공하는 변경된 코드 가이드라인'에 따라
  보다 효율적인 코드를 생성하려고 코드 생성기를 지속적으로 수정하고 있다.
```

이 어셈블리 코드 파일은 아래의 내용을 포함한다.

``` assembly
multstore:
  pushq	  %rbx
movq	%rdx, %rbx
call	mult2
movq	%rax, (%rbx)
popq	%rbx
ret
```

> 코드의 각 라인은 **하나의 기계어 인스트럭션에 대응**된다.
>
> 지역변수 이름이나 데이터 타입에 관한 모든 정보는 삭제되었다.

- pushq 인스트럭션 - `레지스터 %rbx`가 **프로그램 스택에 저장(push)**되어야 한다는 것을 의미한다.



바이너리 형식의 **목적코드(실행코드x)** 파일 mstore.o를 생성하기 위해 명령줄에서 -S 옵션을 사용한다.

``` shell
linux> gcc -0g -c mstore.c
```

기계어 코드 파일의 내용을 조사하려면, `역어셈블러(disassembler)`라고 하는 프로그램이 매우 중요해진다.

**[프로그램의 바이트 표현을 표시하는 방법]**

1. `역어셈블러`를 사용하여 mstore에 대한 이진 목적코드를 표시한다.

   - 

   - multstore프로시저를 위한 코드가 14바이트라는 것을 알 수 있다.

2. GNU 디버깅 도구인 `GDB`를 파일 mstore.o와 함께 실행시키고 다음과 같이 명령을 준다.

   ``` shell
   (gdb)x/14xb multstore
   ```

   - 14개의 16진수 형태(x)의 바이트들(b)을 multstore함수가 위치한 주소에서 시작하여 나타내라는(맨 앞의 x) 명령이다.

   목적코드 파일에서의 multstore함수:

      ``` c
   53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
      ```

   역어셈블리 후 GDB를 사용한 결과:

   