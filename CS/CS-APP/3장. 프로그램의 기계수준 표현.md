> # Part 1: 프로그램의 구조와 실행
>
> 컴퓨터 시스템에 대한 탐구는 프로세서와 메모리 서브시스템으로 구성된 컴퓨터 자체를 공부하는 것으로 시작한다.
>
> - 응용 프로그램이 어떻게 표시되고 실행되는지에 대한 깊은 이해를 할 수 있게 된다.
> - 안전하고 안정적인 프로그램을 작성하고, 컴퓨팅 자원을 가장 잘 사용할 수 있도록 하는 기법을 배운다.

# 3장. 프로그램의 기계수준 표현

컴퓨터는 `인코딩`한 연속된 바이트인 **기계어 코드(machine code)를 실행**한다.

컴파일러는 프로그램 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 **기계어 코드를 생성**한다.

1. GCC `C 컴파일러`는 기게어 코드를 문자로 표시한 **어셈블리 코드**의 형태로 출력을 만들어 **프로그램의 각 인스트럭션을 만들어 낸다**.
2. 그리고 나서, GCC는 `어셈블러`와 `링커`를 호출하여 어셈블리 코드로부터 실행 가능한 **기계어 코드**를 생성한다.

컴파일러에서는 **타입체크 기능**을 제공한다.

- 프로그램 에러를 검출하는 데 도움을 준다.
- 데이터를 균일하게 참조하고 처리하는 일을 정확히 할 수 있도록 도와준다.

최신 최적화 컴파일러가 만들어 낸 코드는 대부분 잘 훈련된 어셈블리어 프로그래머가 작성한 것과 유사한 효율성을 갖는다.

> 그럼에도 우리가 기계어 코드를 배워야 하는 이유는, 
>
> 컴파일러가 만들어 내는 어셈블리 코드들을 읽고 이해하는 기술은 진정한 프로그래머들에게 매우 중요한 기술이기 때문이다.
>
> - 컴파일러를 적절한 커맨드라인 인자와 함께 호출하면 `어셈블리 코드 형태의 파일`로 출력을 생성한다.
>
> - 이 코드를 이해하면 **컴파일러의 최적화 성능**을 알 수 있으며, **코드에 내재된 비효율성**을 분석할 수도 있다.
>
>   - 고급 언어에서 제공하는 추상화 계층 때문에 이해가 필요한 프로그램의 **런타임 동작**이 감춰지는 경우
>   - 악성 프로그램의 공격 방법 중 상당수가 프로그램이 런타임 제어 정보를 저장하는 방식의 미묘한 차이와 관련 있음 
>
>   => 런타임 동작의 정보는 기계어 코드 수준에서 알 수 있다.

**목표**

- C, 어셈블리 코드, 기계어 코드 간의 관계

  - 이 장에서는 한 개의 특정 어셈블리어(`x86-64`)를 배우고, C 프로그램이 어떻게 이들 기계어 코드 형태로 컴파일 되는지 공부한다.

  - 이것은 `역엔지니어링(reverse engineering)`의 일종이다.

    - 역엔지니어링

      : 시스템이 만들어진 과정을 연구하고 역방향으로 분석하여 이해하려는 작업

- x86-64의 세부 사항들

  : 이 기계어는 요즘 사용하는 대부분의 컴퓨터 뿐만 아니라 대규모 데이터 센터나 슈퍼컴퓨터에서도 이용된다.

  - 데이터의 표현과 처리
  - 제어의 구현
    - C언어에서의 제어 구조인 if, while, switch문들이 어떻게 구현되어 있는지

- 프로시저의 구현

  - 지역변수와 프로시저 간에 데이터와 제어를 전달하기 위한 `런타임 스택`을 프로그램이 어떻게 관리하는지

- 배열, 구조체, 유니온 같은 자료구조들이 기계수준에서 어떻게 구현되었는지

  - out-of-bound 메모리 참조 문제
  - 버퍼 오버플로우 공격에 대한 시스템 취약성

- 부동소수점 데이터와 연산과 관련된 코드의 기계어 표현



컴퓨터 업체들은 최근에 32비트에서 64비트 머신으로 전환했다.

- 32비트 컴퓨터 - **4 GB (2^32)**의 램만 사용 가능
- 64비트 컴퓨터 - 최대 **256 TB (2^48)**의 램 사용 가능. 쉽게 16 엑사바이트(2^64)까지도 확장될 수 있다.

> x86-64 프로세서들의 기능 중에서 GCC와 리눅스에서 사용하는 일부분의 기능들만 다루고자 한다.
>
> 아래의 복잡하고 불가사의한 부분들은 대부분 피할 것이다.
>
> - 초창기 16비트 마이크로프로세서 시절의 레거시를 지원하기 위한 x86-64의 많은 기능들
>
> - 대부분의 개발을 인텔이 주도하였지만, 경쟁사인 AMD(Advanced Micro Devices)도 중요한 기여를 해왔기 때문에 다소 기형적인 설계를 가지게 됨

``` c
*IA32(Intel Architecture 32-bit) 프로그래밍
: x86-64의 전 버전인 IA32는 인텔사에 의해 1985년 소개되었다.
 요즘 판매되는 대부분의 x86 마이크로프로세서와 이들 머신에 설치된 대부분의 운영체제는 x86-64를 실행하기 위해 설계된다.
 그렇지만, 이들은 '역방향 호환성 모드' 때문에 IA32 프로그램들도 실행할 수 있다.
 그 결과로 많은 응용 프로그램들은 여전히 IA32에 기초하고 있다.
```

## 1. 역사적 관점

`x86`이라고 통칭하는 **인텔 프로세서 제품군**은 오랜 기간 진화를 통한 개발을 해 왔다.

- 8086 (1978, 29 K 트랜지스터)

  : 이 제품들은 **최초의 단일칩 `16비트` 마이크로프로세서**로 출발했다.

  - 8087 부동소수점 보조 프로세서(1980, 45 K 트랜지스터)

    : 8086이나 8088과 함께 사용하며 `부동소수점 인스트럭션`을 실행하였다.

    8087은 x86 제품군을 위한 부동소수점 모델을 정립하였으며, "`x87`"이라고 불렸다.

- i386 (1985, 275 K 트랜지스터)

  : 구조를 32비트로 확장. 리눅스와 최신 윈도우 운영체제에서 사용하는 `선형 주소모델` 추가

  **유닉스 운영체제를 완벽하게 지원할 수 있는 최초의 컴퓨터**

- 펜티엄 시리즈 (1993 ~ 2004)

  - 펜티엄 4E (2004, 125 M 트랜지스터)

    - `하이퍼쓰레딩(hyperthreading)` 기법의 추가

      : 두 개의 프로그램을 하나의 프로세서에서 동시에 실행할 수 있는 기법

    - AMD사에서 개발한 IA32의 64비트 확장 구현인 EM64T 추가

      => 이를 `x86-64`라고도 한다.

- Core 시리즈 (2006 ~ 2013)

  - Core2 (2006, 291 M 트랜지스터)

    : P6와 유사한 마이크로 구조로 복귀.

    한 개의 칩 내에 멀티 프로세서를 구현한 **최초의 `멀티코어` 인텔 마이크로프로세서**

    멀티코어를 지원하는 대신 `하이퍼쓰레딩`을 지원하지 않음

    - 이후의 Core i7, Nehalem (2008, 781 M 트랜지스터)부터는 멀티코어와 하이퍼쓰레딩을 함께 지원한다.

> - 초기 8086과 그 확장형인 80286에서 사용하는 메모리 모델은 i386(=선형 주소모델)에서는 더 이상 사용되지 않는다.
> - 오리지날 x87 부동소수점 인스트럭션들은 SSE2가 도입되면서부터는 사용하지 않게 되었다.

각각의 인접한 프로세서는 이전 버전과 **호환성**을 갖도록 설계되었다.

따라서 인스트럭션 집합에는 이러한 진화적인 유산 때문에 많은 이상한 잔재기능들이 존재한다.

- x86

  : IA32 (Intel Architecture 32-bit)

  i3**86**과 i4**86**에서 파생된 명명법이다.

- x86-64

  : Intel64 라고도 부른다.

  Intel64는 IA32의 64비트 확장형이라는 의미로 붙여진 이름이다.

> 비록 이 책에서는 인텔 프로세서들에 대해서만 다루겠지만, 본문 내용은 인텔의 경쟁사가 만든 **호환성이 있는 프로세서**들에도 동일하게 적용된다. 



## 2. 프로그램의 인코딩

C 프로그램을 두 개의 파일 p1.c와 p2.c에 작성한다고 하자.

이 코드를 유닉스 커맨드 라인으로 다음과 같이 컴파일 한다:

``` shell
linux> gcc -0g -o p p1.c p2.c
```

- 명령어는 GCC의 `C 컴파일러`를 지정한다.

  (GCC C 컴파일러가 `리눅스에서 기본 컴파일러`이기 때문에 간단히 cc로 호출할 수도 있다)

- 커맨드 라인 옵션 -0g 

  : 공부를 위해서 본래 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 `최적화 수준`을 적용

  - GCC 4.8 버전 이상부터 사용 가능한 최적화 수준이다.

일반적으로 최적화 수준을 올리게 되면 최종 프로그램은 더 빨리 동작하게 되지만, 컴파일 시간이 증가하고, 디버깅 도구를 실행하기가 어려워질 위험이 있다.

**gcc** 명령은 `소스 코드`를 `실행 코드`로 변환하기 위해 일련의 프로그램들을 호출한다.

1. C 전처리기

   - #include로 명시된 파일을 코드에 삽입
   - #define으로 선언된 `매크로`를 확장

2. 컴파일러

   : 두 개의 소스파일의 `어셈블리` 버전인 p1.s와 p2.s를 생성

3. 어셈블러

   : 어셈블리 코드를 `바이너리 목적코드`인 p1.o와 p2.o를 생성

   - 목적코드는 **기계어 코드의 한 유형**이다

     ; 모든 인스트럭션의 바이너리 표현을 포함하고 있지만 **전역 값들의 주소는 아직 채워지지 않았다**.

4. 링커

   : 두 개의 목적코드 파일을 `라이브러리 함수`들을 구현한 코드와 함께 합쳐서 `최종 실행파일`인 p를 생성한다.

   (명령줄 디렉티브 -o p)

   - 실행 코드는 **기계어 코드의 두 번째 유형**이다

     ; 실행 코드는 **프로세서가 실행할 정확한 코드의 형태**이다.

### 1) 기계수준 코드

컴퓨터 시스템은 보다 간단한 `추상화 모델`을 이용해서 세부 구현내용을 감추면서 추상화의 여러 가지 다른 형태를 사용하고 있다.

이들 중에 두 가지 **추상화**가 기계수준 프로그래밍에서 특히 중요하다.

1. ISA (인스트럭션 집합구조, Instruction set architecture)

   : 기계수준 프로그램의 **형식**과 **동작**은 `ISA`에 의해 정의된다.

   ISA는 `프로세서의 상태`, `인스트럭션의 형식`, `프로세서 상태에 대한 각 인스트럭션들의 영향들`을 정의한다.

   - ISA는 실제 **프로세서 하드웨어의 추상화**를 제공한다. 

     이러한 추상화로 인해 기계어 코드 프로그램은 마치 한 번에 하나의 인스트럭션을 실행하는 프로세서에서 실행되는 것처럼 동작한다.

   - (x86-64 포함) 대부분의 ISA는 마치 하나의 인스트럭션이 다음 인스트럭션의 실행 전에 완료되는 `순차적인 실행`을 하는 것처럼 프로그램의 동작을 설명한다.

     프로세서 하드웨어는 훨씬 정교해서 여러 인스트럭션을 동시에 실행하지만, `ISA에 의한 순차적 동작`과 일치하는 전체 동작을 보이도록 해주는 **안전장치**를 사용한다.

   - 위와 같이 동일한 실행모델(=순차적인 모델)을 유지하기 때문에, **다른 프로세서에 구현될 때도 동일한 기계어 코드를 실행할 수 있게 된다**.

     - 하지만 그 비용과 성능의 범위는 다양하다. 

2. 가상주소

   : 기계수준 프로그램이 사용하는 주소는 `가상주소`이며, 메모리가 **매우 큰 바이트 배열**인 것처럼 보이게 하는 메모리 모델을 제공한다.

   실제 메모리 시스템은 여러 개의 메모리 하드웨어와 운영체제 소프트웨어로 구현되어 있다.

`컴파일러`는 C에서 제공하는 추상화된 실행모델로 표현된 프로그램을, 프로세서가 실행하는 인스트럭션들로 변환하는 대부분의 일을 수행한다.

- 어셈블리 코드 - 텍스트 형식. 더 읽기 쉽다.

- 기계어 코드 - 바이너리 형식

x86-64를 위한 기계어 코드는 C 코드와 달리 `프로세서의 상태`를 명시한다:

- 프로그램 카운터(PC, x86-64에서는 %rip라고 함)

  : 실행할 다음 인스트럭션의 메모리 주소를 가리킨다.

- 정수 레지스터 파일

  : `64비트 값`을 저장하기 위한 **16개의 이름을 붙인 위치**를 갖는다.

  이들 레지스터는 **주소**(C언어의 포인터에 해당하는)나 **정수 데이터**를 저장할 수 있다.

  - 일부 레지스터는 프로그램의 중요한 `상태`를 추적하는 데 사용
  - 다른 레지스터들은 함수의 `리턴 값`, 프로시저의 `지역변수`와 `인자` 같은 임시 값을 저장

- 조건코드 레지스터

  : **가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 `상태 정보`**를 저장한다.

  이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다.

- 벡터 레지스터

  : 벡터 레지스터들의 집합은 `하나 이상의 정수`나 `부동소수점 값`들을 각각 저장할 수 있다.

C가 다른 종류의 `데이터 타입`을 **선언**하고 **메모리에 할당**할 수 있는 모델을 제공하는 반면, 기계어 코드는 메모리를 단순히 `바이트 주소지정이 가능한 큰 배열`로 본다. (1byte 단위로 가상주소 할당하기가 가능함)

- 기계어 코드에서는 C에서 배열과 구조체 같은 연결된 데이터 타입들은 **연속된 바이트들**로 표시된다.
- 어셈블리 코드는 스칼라(scalar) 데이터 타입-단 하나의 값만을 저장할 수 있는 데이터 타입-의 경우에도 데이터 타입들 사이를 전혀 구분하지 않는다. (데이터 타입에 관한 모든 정보는 삭제됨)
  - 부호형과 비부호형
  - 포인터와 정수형 사이 등 (어셈블리 코드에는 포인터 데이터 타입이 없음)

**[프로그램 메모리(가상메모리)]**

- 프로그램의 실행 기계어 `코드`, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 `런타임 스택`, 사용자에 의해 할당된(ex. malloc 라이브러리 함수) 메모리 블록들을 포함하고 있다.
- 가상주소의 일부 제한된 영역만이 `유효`하다.
  - x86-64 가상주소들은 **64비트 워드**들로 표현된다.
  - 현재(책 출시 당시) x86-64 기계들의 구현은 상위 16비트는 0으로 지정되어야 하고, 따라서 주소는 2^48 B = 256 TB 범위까지의 메모리를 이용할 수 있으며, 그 이상은 16엑사바이트(2^64 B)까지도 쉽게 확장될 수 있다.
  - 하지만 전형적인 프로그램들은 오직 몇 MB 혹은 몇 GB에 접근할 것이다.

> **운영체제**는 이 가상 주소공간을 **관리**해서 가상주소를 실제 프로세서 메모리 상의 **물리적 주소 값으로 번역**해준다.

하나의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다.

`컴파일러`는 **일련의 인스트럭션을 생성**해서 산술연산식의 계산, 반복문, 프로시저 호출과 리턴 등의 프로그램 구문을 구현해야 한다.

### 2) 코드 예제

다음과 같은 **프로시저 정의**를 포함하고 있는 C 코드 파일 mstore.c를 작성한다.

``` c
long mult2(long, long);

void multstore(long x, long y, long* dest){
    long t = mult2(x, y);
    *dest = t;
}
```

C 컴파일러가 생성한 **어셈블리 코드**를 보기 위해서 명령줄에서 `-S` 옵션을 사용할 수 있다.

- 이것은 컴파일러를 실행해서 어셈블리 파일 mstore`.s`를 만들고, 더 이상 진행하지 않는다.

``` shell
linux> gcc -0g -S mstore.c
```

``` c
*지속적으로 변하는 생성된 코드의 형태
 : 다른 컴파일러나 다른 버전의 GCC를 사용하면 다른 코드를 생성한다.
  GCC를 지원하는 오픈소스 커뮤니티는 '마이크로프로세서 생산업체에서 제공하는 변경된 코드 가이드라인'에 따라
  보다 효율적인 코드를 생성하려고 코드 생성기를 지속적으로 수정하고 있다.
```

이 어셈블리 코드 파일은 아래의 내용을 포함한다.

``` assembly
multstore:
	pushq	%rbx
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	ret
```

> 코드의 각 라인은 **하나의 기계어 인스트럭션에 대응**된다.
>
> 지역변수 이름이나 데이터 타입에 관한 모든 정보는 삭제되었다.

- pushq 인스트럭션 - `레지스터 %rbx`가 **프로그램 스택에 저장(push)**되어야 한다는 것을 의미한다.



바이너리 형식의 **목적코드(실행코드x)** 파일 mstore.o를 생성하기 위해 명령줄에서 `-c` 옵션을 사용한다.

``` shell
linux> gcc -0g -c mstore.c
```

기계어 코드 파일의 내용을 조사하려면, `역어셈블러(disassembler)`라고 하는 프로그램이 매우 중요해진다.

**[프로그램의 바이트 표현을 표시하는 방법]**

1. `역어셈블러`를 사용하여 mstore에 대한 이진 목적코드를 (어셈블리어 코드와 유사한 형태로)표시한다.

   - 역어셈블러 프로그램들은 기계어 코드로부터 어셈블리어 코드와 유사한 형태를 생성한다.

   - 리눅스 시스템에서 프로그램 OBJDUMP(object dump의 약어)에 `-d` 커맨드 라인을 사용하면 된다.

     ``` shell
     linux> objdump -d mstore.o
     ```

     => 결과를 보면 multstore프로시저를 위한 코드가 14바이트라는 것을 알 수 있다.

2. GNU 디버깅 도구인 `GDB`를 파일 mstore.o와 함께 실행시키고 다음과 같이 명령을 준다.

   ``` shell
   (gdb)x/14xb multstore
   ```

   - 14개의 16진수 형태(x)의 바이트들(b)을 multstore함수가 위치한 주소에서 시작하여 나타내라는(맨 앞의 x) 명령이다.


목적코드 파일에서의 multstore함수:

   ``` 
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
   ```

역어셈블리 후 GDB를 사용해서 multstore함수만 나타낸 결과:

``` assembly
0000000000000000 <multstore>:
/*offset	Bytes				동치인 어셈블리어*/
	  0:	53					push	%rbx
	  1:	48 89 d3			mov		%rdx, %rbx
	  4:	e8 00 00 00 00		callq	9 <multstore+0x9> /*mult2 함수 프로토타입만 선언됨*/
	  9:	48 89 03			mov		%rax, (%rbx)
	  c:	5b					pop		%rbx
	  d:	c3					retq
```

기계어 코드의 특징

- x86-64 인스트럭션들은 1에서 15바이트 길이를 갖는다.
  - 자주 사용되는 인스트럭션들, 오퍼랜드가 적은 인스트럭션들 -> 짧은 길이로 인코딩
  - 그 반대의 경우 -> 좀 더 긴 길이로 인코딩
- 인스트럭션의 형식은 **시작 위치의 바이트들로부터 유일하게 디코딩**할 수 있도록 설계한다.
  - ex) pushq %rbx 인스트럭션만이 바이트 값 53으로 시작될 수 있다.

기계어 코드의 역어셈블된 표현

- 역어셈블러는 기계어 코드 파일의 **바이트 순서**에만 전적으로 의존해서 어셈블리 코드를 결정한다.
- 역어셈블러는 GCC가 생성한 어셈블리 코드와는 약간 다른 명명법을 인스트럭션에 사용한다.
  - 많은 인스트럭션들이 접미어 'q'를 생략
  - 반대로 역어셈블러는 접미어 'q'를 call과 ret 명령어에 붙인다.
    - 접미어들은 대부분의 경우에 **생략**할 수 있다.



**실행 가능 코드**를 생성하기 위해서 `링커`를 목적코드들에 대해 실행해야 한다.

- 이들 중 한 개의 파일은 main함수를 포함해야 한다. 

``` shell
linux> gcc -0g -o prog main.c mstore.c
```

파일의 크기가 증가하는 이유는

- 우리가 제공한 두 개의 프로시저,
- 운영체제와 상호작용하기 위한 코드,
- 프로그램을 시작하고 종료하기 위한 코드들까지 포함하기 때문이다.

파일을 다음과 같이 역어셈블 할 수 있다.

``` shell
linux> objdump -d prog
```

역어셈블리 후 GDB를 사용해서 multstore함수만 나타낸 결과:

``` assembly
0000000000400540 <multstore>:
/*offset	Bytes				동치인 어셈블리어*/
400540:		53					push	%rbx
400541:		48 89 d3			mov		%rdx, %rbx
400544:		e8 42 00 00 00		callq	40058b <mult2> /*mult2 함수의 정의가 main.c에 있음*/
400549:		48 89 03			mov		%rax, (%rbx)
40054c:		5b					pop		%rbx
40054d:		c3					retq
40054e:		90					nop
40054f:		90					nop
```

이 코드는 mstore.c를 역어셈블러 해서 생성한 것과 거의 동일하지만 중요한 차이점들이 있다.

1. 왼쪽에 나타낸 주소가 다르다.

   : 링커가 이 코드의 위치를 `다른 주소 영역`으로 이동하였다.

2. 링커가 callq 인스트럭션이 함수 mult2를 호출할 때 사용해야 하는 주소를 채웠다.

   > 링커의 한 가지 임무는 함수들을 위한 실행 코드의 위치들과 함수 호출을 일치시키는 것이다.

3. 두 줄의 라인이 추가되었다.
   : 이들 인스트럭션은 리턴 인스트럭션 후에 발생하기 때문에 프로그램에는 아무 효과가 없다.

   함수를 위한 코드 길이를 **16바이트**로 늘려서 **코드의 다음 블록을 메모리 시스템 성능 면에서 더 잘 배치하기 위해** 삽입되었다.

### 3) 형식에 대한 설명

`컴파일러`에 의해 생성된 mstore.s

``` assembly
	.file	"010-mstore.c"
	.text
	.global	multstore
	.type	multstore, @function
/* void multstore(long x, long y, long* dest) */
/* x in %rdi, y in %rsi, dest in %rdx */
multstore:
	pushq	%rbx		/* Save %rbx */
	movq	%rdx, %rbx	/* Copy dest to %rbx */
	call	mult2		/* Call mult2(x, y) */
	movq	%rax, (%rbx)/* Store result at *dest */
	popq	%rbx		/* Restore %rbx */
	ret					/* Return */
```

- '.'으로 시작하는 모든 라인은 `어셈블러`와 `링커`에게 지시하기 위한 디렉티브(directive)들이다.

  일반적으로 이들은 무시해도 된다.

``` c
*ATT와 인텔 어셈블리 코드 형식
 1. ATT형식
    : 본문에서는 어셈블리 코드를 ATT형식(AT&T사의 이름을 땄다)으로 나타낸다.
     GCC, OBJDUMP, 그 외 다른 여러 도구들에서도 사용하는 기본형식이다.
 2. 인텔 형식
    : 마이크로소프트사와 인텔에서는 인텔형식으로 어셈블리 코드를 보여준다.
     GCC는 다음과 같은 명령어를 사용하면 multstore함수를 인텔 형식의 코드로 생성해준다.
        linux> gcc -0g -S -masm=intel mstore.c
     결과는
        multstore:
			push	rbx
            mov 	rbx, rdx
            call	mult2
            mov		QWORD PTR [rbx], rax
            pop		rbx
            ret
**인텔 형식의 특징
 1. 크기를 나타내는 q 접미어를 생략한다.
 2. '%' 문자를 레지스터 이름 앞에서 생략한다.
 3. 다른 방법을 사용해서 메모리 위치를 나타낸다.
    ex) (%rbx) 대신 QWORD PTR [rbx] 사용
 4. 여러 개의 오퍼랜드를 갖는 인스트럭션들을 역순으로 나열한다. 따라서 매우 혼란스러울 수 있다.
    ex) %rax, (%rbx) 대신 QWORD PTR [rbx], rax 사용
```

**[어셈블리 코드를 C 프로그램과 연동하는 방법]**

C 프로그램으로 접근할 수 없는 하드웨어 기능들이 존재한다.

- ex) 조건코드 PF(parity flag)

어셈블리 코드를 C 프로그램 내에 연결하는 두 가지 방법이 있다.

1. 전체 함수를 별도의 어셈블리 파일로 작성하고, `어셈블러`와 `링커`가 이것을 C로 작성한 코드와 함께 연결하도록 하는 방법

2. GCC의 인라인(inline) 어셈블리 기능을 사용하는 방법

   : 어셈블리 코드의 간단한 영역을 C 프로그램에서 **asm 디렉티브**를 사용해서 연결하는 것이다.

   이 방법은 기계어와 관련된 코드의 양을 최소화 할 수 있다는 장점이 있다.

> 어셈블리 코드를 C 프로그램 내에 삽입하면 코드를 특정한 종류의 컴퓨터(x86-64 같은)에 국한하게 된다.
>
> 따라서 원하는 기능이 오직 이러한 방법으로만 구현할 수 있는 경우로 제한되어야 한다.



## 3. 데이터의 형식

인텔 프로세서들이 근본적으로 `16비트 구조`를 사용하다가 추후에 `32비트`로 확장했기 때문에 인텔은 **"워드"**라는 단어를 **16비트 데이터 타입**을 말할 때 사용한다.

- 워드 = 16비트
- 더블워드 = 32비트
- 쿼드워드 = 64비트

**[C에서 기본 데이터 타입에 사용되는 x86-64표시]**

<img src="images/03_x86-64_C_data_type.jpg" style="zoom:50%;" />

- 표준 int값 - `더블워드`로 저장(32비트)
- 포인터 - 64비트 머신이므로 `쿼드워드`로 저장(64비트)
- long - **x86-64에서 64비트로 구현됨.** `쿼드워드`로 저장

> 이 장의 대부분의 코드 예제들은 **포인터**와 **long** 데이터 타입을 이용하며, 그래서 이들은 `쿼드워드`로 동작한다.

x86-64 인스트럭션 집합은 쿼드워드(64비트 머신) 외에도 바이트, 워드, 더블워드를 위한 **보조 인스트럭션**들도 포함한다.

`GCC`가 생성한 대부분의 어셈블리 코드 인스트럭션들은 **오퍼랜드의 크기를 나타내는 접미어**를 가지고 있다.

- 데이터 이동 인스트럭션

  - movb (바이트 이동)

  - movw (워드 이동)

  - mov`l` (더블워드 이동)

    : 32비트 양(4바이트 정수)이 "long word"로 간주되기 때문

  - movq (쿼드워드 이동)

> 부동소수점의 경우에는 완전히 다른 인스트럭션과 레지스터들을 사용한다.
>
> 따라서 어셈블리 코드가 접미어 '`l`'을 4바이트 정수뿐만 아니라 8바이트 더블 정밀도 부동소수점 수를 나타내기 위해서도 사용한다는 사실이 혼란을 야기하지는 않는다.

부동소수점 숫자에는 두 개의 기본 형태가 있다:

1. C의 float 타입에 대응되는 단일 정밀도(4바이트) 값
2. C의 double 타입에 대응되는 이중 정밀도(8바이트) 값

x86 계열의 마이크로 프로세서들은 역사적으로 특별한 80비트(10바이트) 부동소수점 형식으로 동작하는 부동소수점 연산을 구현하였다.

이 형식은 C 프로그램에서는 long double을 선언해서 명시할 수 있다.

그러나 이 형식을 이용하지 않는 것을 추천한다.

- x86 머신이 아닌 다른 종류의 머신들에서는 호환성이 없고,
- 단일 정밀도와 이중 정밀도 산술연산을 위한 경우에서와 동일한 고성능의 하드웨어로 구현되어 있지 않다.



## 4. 정보 접근하기

x86-64 주처리장치 CPU는 **64비트 값**을 저장할 수 있는 **16개의 범용 레지스터(정수 레지스터)**를 보유하고 있다.

이들 레지스터는 `정수 데이터`와 `포인터`를 저장하는 데 사용한다.

<img src="images/03_integer_register.jpg" style="zoom:80%;" />

이름은 모두 **%r**로 시작하지만, 인스트럭션 집합의 역사적인 진화 과정을 이유로 여러 개의 다른 명명법을 따른다.

- 8086

  : %ax에서 %sp까지 `16비트` 레지스터를 가짐

  각각은 **특정한 목적**을 가졌으며, 따라서 사용되는 방법을 반영하는 이름을 붙였다.

- IA32로 확장

  : 이 레지스터들은 `32비트`로 확장되어 %**e**ax에서 %**e**sp까지 이름을 붙였다.

- x86-64로 확장

  : 본래의 8개 레지스터들은 %**r**ax에서 %**r**sp까지 `64비트`로 확대되었다.

  여기에 8개의 새로운 레지스터들이 추가되었으며, 이들은 새로운 명명법에 따라 %**r**8에서 %**r**15까지로 이름을 붙였다.

인스트럭션들은 16개의 레지스터 하위 바이트들에 저장된 다양한 크기의 데이터에 대해 연산할 수 있다.

- 바이트 수준 연산 - LSB에 대해 접근해서 연산을 할 수 있다.
- 16비트 연산 - LSB부터 2바이트에 접근 가능
- 32비트 연산 - LSB부터 4바이트에 접근 가능
- 64비트 연산 - 레지스터 전체에 접근 가능

1, 2, 4, 8바이트 값들을 `복사`하고 `생성`하는 인스트럭션들이 있다.

이 인스트럭션들이 **레지스터들을 목적지로 할 때**에는 8바이트보다 작은 바이트를 `생성`하는 인스트럭션들의 레지스터에서 남는 바이트들에 대해 어떻게 처리해야 하는지 결정해야 한다.

1. 1 또는 2바이트를 생성하는 경우에는 나머지 바이트들은 변경 없이 그대로 유지된다.

2. 4바이트 길이의 값을 생성하는 경우는 상위 4바이트를 0으로 설정한다.

   이러한 방식은 IA32에서 x86-64로 오면서 채택한 방식이다.



> 일반적인 프로그램에서 서로 다른 레지스터들은 서로 다른 목적으로 이용된다.

가장 특이한 스택 포인터를 제외하고 다른 15개의 레지스터들은 사용이 좀 더 자유롭다.

- 스택 포인터 %rsp

  : `런타임 스택`의 끝부분을 가리키기 위해 사용됨.

  **일부 인스트럭션들은 특별히 이 레지스터를 읽고 쓴다.**

몇 개의 인스트럭션들은 특정 레지스터들에 국한되어 사용한다.

중요한 것은 '레지스터가 어떻게 사용되는지'는 `일련의 표준 프로그래밍 관습(프로시저 구현방법 등의 관례)`에 의해 정해진다는 점이다.

- 스택을 관리
- 함수의 인자 넘기기
- 함수에서 값을 리턴하기
- 로컬 데이터와 임시 데이터를 저장

### 1) 오퍼랜드 식별자(specifier)

대부분의 인스트럭션은 하나 이상의 `오퍼랜드`를 가진다.

오퍼랜드는 연산을 수행할 **소스(source) 값**과 그 결과를 저장할 **목적지(destination)의 위치**를 명시한다.

- 소스 값 - `상수`로 주어지거나 `레지스터`나 `메모리`로부터 읽을 수 있다.
- 결과 값 - `레지스터`나 `메모리`에 저장된다.

<img src="images/03_operand.jpg" style="zoom:50%;" />

**[오퍼랜드의 종류(x86-64, ATT 형식)]**

1. immediate (즉시값)

   : 상수값을 말한다.

   - 어셈블리 코드에서 쓰는 기호 - `$ 기호 + C 표준 서식을 사용하는 정수` ex) $-577, $0x1F

   - 실제 값 - $ 기호를 뺀 `C 표준 서식을 사용하는 정수`

   인스트럭션에 따라 다양한 범위의 상수 값을 사용할 수 있다.

   - **어셈블러**는 해당 값을 인코딩하는 **가장 컴팩트한 방법을 자동으로 선택**한다.

2. register (레지스터 값)

   : 각각 16개의 64비트, 32비트, 16비트, 8비트 레지스터들의 하위 일부분인 8, 4, 2, 1바이트 중에, 하나의 레지스터를 가리킨다.

   - 어셈블리 코드에서 쓰는 기호 - `r_a`는 임의의 레지스터 a를 나타낸다.
   - 실제 값 - 해당 값은 `R[r_a]`을 참조하여 지정되며, 레지스터 집합을 배열 R과 레지스터 식별자를 인덱스로 사용하는 형태로 나타낸다.

3. 메모리 참조

   : **유효주소(effective address)**라고 부르는 계산된 주소에 의해 메모리 위치에 접근하게 된다.

   - 실제 값 - `M_b[Addr]`. 메모리는 거대한 바이트의 배열 M으로 생각하고 <u>메모리 주소 Addr(= 유효주소)</u>부터 저장된 b 바이트를 참조하는 것을 나타낸다.

     (단순화를 위해 일반적으로 아래첨자 b는 생략한다)

   여러 가지 유형의 메모리 참조를 가능하게 하는 많은 **주소지정방식**이 존재한다.

   - 가장 일반적인 형태 `Imm(r_b, r_i, s)`

     - 상수 오프셋 Imm
     - 베이스 레지스터 r_b - 64비트 레지스터
     - 인덱스 레지스터 r_i - 64비트 레지스터
     - 배율 s - 1, 2, 4, 8의 값을 가짐

     : **유효주소**는 Imm + R[r_b] + R[r_i]*s 로 계산된다.

     이 형태는 `배열`의 원소를 참조할 때 종종 볼 수 있다.

     > 위 그림에서 다른 형태들은 모두 이들 구성요소의 일부가 생략된 특별한 경우이다. 

   - 배열과 구조체 원소의 참조

     : 보다 복잡한 주소지정방식이 필요함

### 2) 데이터 이동 인스트럭션

가장 많이 사용되는 인스트럭션은 데이터를 한 위치에서 다른 위치로 `복사`하는 명령이다.

