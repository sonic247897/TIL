# 4장. 데이터베이스와 아키텍처 구성

> 고속의 견고한 시스템을 구축하기 위해서는 아키텍처가 명확한 의도로 설계되어야 한다.

**데이터베이스는 견고하게 유지되는 것이 요구된다.** 문제가 발생할 때마다 정지해서는 인프라로써의 역할을 다하지 못하기 때문.

- 다중화 - DB 서버를 여러대 두어 1대가 고장난다 하더라도 나머지 서버가 동작하면 서비스의 정지를 막을 수 있다.

  ​	즉 예비용이 준비된 것. `고가용성`이라고도 부른다.

## 1. 아키텍처란

> 데이터베이스의 설계 중에서 **아키텍처(시스템의 구성)**에 관해 살펴본다.

'아키텍처'란 말은 다양한 의미가 있지만, 이 장에서는 주로 '**시스템을 만들기 위한 물리 레벨의 조합**'이란 의미로 사용한다.

구체적으로는 '어떤 기능을 가진 서버를 준비하고 어떠한 저장소나 네트워크 기기와 조합해서 시스템을 만들 것인가' 즉 **하드웨어와 미들웨어의 구성**을 가리킨다.

이 구성을 **시스템이 완수해야 할 목적과 비교하면서 결정**해 가는 것이 `아키텍처 설계`이다.

('물리 설계'로 불러도 좋겠지만, 시스템의 '뼈대'를 생각하는 상위 설계란 함축적 의의가 담겨있다)

- 아키텍처 설계는 매우 심도 있는 영역이라서 이를 목표로 한다면 데이터베이스 + 서버부터 OS, 기타 미들웨어, 저장소, 로드밸런서에 방화벽 같은 네트워크 기기까지 폭넓은 지식이 필요하다.
- 아키텍처는 시스템 개발 후반이 되면 변경하기가 어려우므로 프로젝트의 성패는 초반에 결정되는 것이 일반적이다.



## 2. 데이터베이스의 아키텍처

### ① 역사와 개요

1. Stand-alone (~1980년대)

   > 데이터베이스만으로 시스템이 성립하는 가장 간단한 방법

   직역하면 '혼자'라는 의미이다. Stand-alone은 문자 그대로 DB 서버가 LAN이나 인터넷 등의 네트워크에 접속하지 않고 **독립되어** 동작하는 구성이다.

   이 구성에서는 DBMS와 애플리케이션 소프트웨어는 같은 DB 서버에서 동작한다.

   따라서 데이터베이스를 사용하고 싶은 사용자는 **DB 서버가 설치된 장소까지 물리적으로 접근**하여 서버 앞에 앉아서 데이터베이스를 이용해야 한다.

   **[Stand-alone의 단점]**

   현대적인 컴퓨터가 막 등장하기 시작한 이 시기에는 `네트워크`라는 아이디어가 없었기 때문에 모든 컴퓨터가 Stand-alone 구성이었다. 현재는 이 원시적인 Stand-alone 구성은 극히 소규모 작업 환경이나 테스트 환경을 제외하면 거의 볼 수 없다.

   - 물리적으로 떨어진 장소에서 접근할 수 없다

   - 복수 사용자가 동시에 접속할 수 없다

     : 서버 앞에서 1명씩만 사용할 수 있으므로 대기열이 늘어난다.

   - 가용성이 낮다

     : 서버가 1대밖에 없으므로 이 1대에 장애가 발생하면 서비스가 정지한다는 큰 단점이 있다.

     - **가용성(Availablity)** - 시스템이 서비스 제공시간에 **장애 없이** 서비스를 계속 지속할 수 있는 비율이 어느 정도인가를 나타내는 개념

   - 확장성이 부족하다

     : '성능이 나쁘다'는 것 이상으로 성능이 나쁠 때 '개선 수단'이 매우 부족하다.

     실제 머신이 1대밖에 없다는 것은 머신 그 자체의 성능을 올리는 방법(서버를 상위기종으로 교환하거나 더 고성능의 부품으로 교환함) 이외에 개선 수단이 없다는 것을 의미한다.

     이러한 구성을 '`확장성(Scalability)`이 부족하다'고 표현한다. 

   => 물리적으로 떨어진 장소에서는 접근할 수 없고, 복수 사용자가 동시에 접속할 수 없다는 두 가지 단점은, 서버와 네트워크를 연결하는 것이 해결책이다. 하지만 가용성과 확장성은 단순히 서버를 네트워크에 접속하게 하는 것으로는 해결되지 않고 **특별한 대책**이 필요하다.

   **[Stand-alone의 장점]**

   - 구축이 매우 간단해서 소규모 작업이나 테스트를 빨리 할 수 있다

   - 보안이 매우 높다

     : 네트워크를 매개로 침입할 위험이 없기 때문

2. 클라이언트/서버 (1990년대~2000년)

   > 클라이언트와 서버로 계층을 분리하여 상호 간에 네트워크로 접속하는 방법

   Stand-alone의 단점을 극복하기 위해 데이터베이스를 **네트워크**에 연결하여, 복수 사용자가 물리적으로 떨어진 장소에서 데이터베이스에 접속할 수 있게 되었다.

   <img src="images/04_client_server.jpg" style="zoom:50%;" />

   DB 서버에서는 DBMS가 동작하고 클라이언트에서는 업무 애플리케이션이 동작하는 분업체제로 볼 수 있다.

   ``` java
   **서버와 클라이언트의 구별
       -클라이언트: 엔드 사용자가 직접 조작해서 수행하고 싶은 처리 명령을 내보내는 머신
       -서버: 클라이언트로 받은 명령을 실행하여 업무 처리(비즈니스 로직)를 실행하기 위한 머신
           용도에 따라 '웹 서버, 애플리케이션 서버, DB 서버' 등의 이름이 붙어있다.
   ```

   **[클라이언트/서버의 확장]**

   이 구성은 주로 기업이나 조직 내에 **닫힌 네트워크(LAN)에서 이용**되었다. 즉 인터넷 등 외부 네트워크를 거쳐 데이터베이스 서버에 사용자가 접속하는 일은 없었다.

   그 이유는 데이터베이스가 매우 중요한 정보를 많이 축적하고 있는 서버라서 외부로부터의 접속을 허가해버리면 **보안상의 위험**이 증가하기 때문이다.

   - 현재는 조직 내에서 제한된 용도의 시스템으로 이용되고 있다.

   **[클라이언트/서버 구성의 단점]**

   **인터넷을 통해 시스템을 이용할 때** 이 구성은 2가지 문제점이 존재한다.

   1) 인터넷에서 직접 데이터베이스에 접속하는 것에 대한 보안 위협

   2) 불특정 다수의 사용자가 사용하는 클라이언트에서의 애플리케이션 `관리비용`이 많이 든다

   - 클라이언트/서버 시대에는 개인이 이용하는 PC에 `애플리케이션`을 설치해 동작하게 했다. (=**네이티브Native 애플리케이션: 애플리케이션을 클라이언트에서 관리함**- Windows용 GUI 애플리케이션은 C나 Basic을 이용하여 만들었다)

     그러나 인터넷을 통해 전 세계 불특정 다수가 이용하는 애플리케이션은 각자의 환경에 대응해 애플리케이션을 작성하고 버전 관리를 따로 해야 하므로 비현실적인 비용이 필요하게 된다.

   <img src="images/04_native_app.jpg" style="zoom:50%;" />

3. Web 3계층 (2000년~현재)

   > 클라이언트/서버를 더욱더 발전시킨 것
>
   > 현재 웹 시스템에서 거의 표준으로 사용된다.

   '네이티브 애플리케이션의 관리비용 문제' 때문에 비즈니스 로직을 실행하는 **애플리케이션을 서버에서 관리**해 비용을 절감하는 `Web 3계층` 구성이 제시되었다. (서버에서 Java로 구현)
   
   Web 3계층은 시스템을 다음 3가지 계층의 조합으로 생각하는 모델이다.
   
   - 웹 서버 계층
   - 애플리케이션 계층
   - 데이터베이스 계층
   
   <img src="images/04_web3_structure.jpg" style="zoom:50%;" />
   
   `클라이언트/서버` 구성과 다른 점은 클라이언트와 데이터베이스 계층 사이에 '**웹 서버 계층**'과 '**애플리케이션 계층**'이 추가된다는 점이다.
   
   - 웹 서버 계층
   
     : 클라이언트로부터 **접속 요청(HTTP 요청)을 직접 받아서** 그 처리를 뒷단의 애플리케이션 계층(애플리케이션 서버)에 넘기고 그 결과를 클라이언트에 반환한다. 
   
     즉 애플리케이션 서버와 클라이언트 웹 브라우저 사이의 다리 역할을 한다.
   
     - 아파치(Apache), IIS(Internet Information Services) 등
   
   - 애플리케이션 계층
   
     : **비즈니스 로직을 구현한 애플리케이션이 동작하는 층**이다. 
   
     웹 서버로부터 연계된 요청을 처리하고, 필요하면 데이터베이스 계층(DB 서버)에 접속해서 데이터를 추출하고 이를 가공한 결과를 웹 서버로 반환한다.
   
     - 톰캣(Tomcat), 웹로직(WebLogic), 웹스피어(WebSphere) 등
   
   > 이처럼 **사용자로부터 직접적인 접속 요청을 받는 역할을 웹 서버 계층에 한정**하여 애플리케이션 계층과 데이터베이스 계층의 **보안**을 높일 수 있다. 
   >
   > 동시에 애플리케이션 계층에 비즈니스 로직을 집중해서 애플리케이션 관리 비용을 낮추는 구성이 될 수 있다.

### ② 가용성과 확장성의 확보

`Web 3 계층`으로 `Stand-alone` 구성의 단점 중 2가지 문제는 해결했다.

​	① 물리적으로 떨어진 장소에서 접근할 수 없다 

​	② 복수 사용자가 동시에 작업할 수 없다

하지만 아직 다음과 같은 문제들이 남아있다.

​	③ 가용성이 낮다 (**서버가 1대밖에 없기 때문에** 장애가 일어나면 서비스가 정지한다) 

​	④ 확장성이 부족하다 (**서버가 1대밖에 없기 때문에** 해당 서버의 성능이 한계에 달하는 경우 서버를 상위 기종으로 교환하거나 고성능 부품으로 교환하는 것 외에는 성능을 개선할 방법이 없다)

**[가용성을 높이는 2가지 전략]**

아키텍처 설계에서 **견고한 시스템**을 만들기 위해 가장 중요한 점이 `가용성`이다.

1. 고품질-소수전략

   : 시스템을 구성하는 **각 컴포넌트의 <u>신뢰성</u>을 높여 장애 발생률을 낮게 억제해서** <u>가용성</u>을 높인다.

   ``` java
   *신뢰성과 가용성
       -신뢰성(Reliability)
        : 하드웨어나 소프트웨어 같이 시스템을 구성하는 컴포넌트에 적용하는 개념으로, 컴포넌트가 고장나는 빈도나 고장기간을 나타냄
       -가용성(Availability)
        : 시스템 전체에 적용하는 개념으로, 사용자 입장에서 볼 때 시스템을 어느 정도 사용할 수 있는지를 나타냄.
          일반적으로 백분율로 나타낸다.(가용률)
   	=> 따라서 신뢰성이 낮은 하드웨어나 소프트웨어를 사용하고 있다 하더라도 다중화(클러스터링) 한다면
         시스템 전체의 가용성을 높일 수 있다.
   ```

   - FT 서버 (Fault Tolerant Server)

     : 1대의 물리 머신의 신뢰성을 매우 높이고, 장애 발생률을 매우 낮게 억제하도록 만들어졌다.

     전환시간을 짧게 하고, 무정지에 가까운 서비스를 계속하는 것이 가능하다는 장점이 있다.

     => 하지만 FT 서버 내부는 CPU, 메모리, 네트워크 인터페이스 같은 부품을 `다중화`해서 신뢰성이 높도록 설계된 부분이 많다.  

2. 저품질-다수전략

   : 시스템을 구성하는 각 컴포넌트의 신뢰성을 계속 높이기보다는 **여분을 준비**해 둔다. (컴포넌트를 병렬화한다)

   **효율성이 우수하다는 것이 증명되어 현재는 거의 이 전략을 채택하고 있다.**

   - 클러스터

     : 이처럼 **동일한 기능의 컴포넌트를 병렬화하는 것**을 `클러스터링(Clustering)`이라고 부른다.

     '클러스터'는 사물이나 사람의 집합을 가리키는 말이다. 이 의미처럼 시스템 세계에서는 '**<u>동일한 기능</u>의 컴포넌트를 복수 개 준비해 <u>한 개의 기능</u>을 실현한다**'는 의미로 사용한다.

   - 단일 장애점

     : 다중화되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트를 `단일 장애점(SPOF, Single Point Of Failure)`이라고 한다.

     단일 장애점의 신뢰성이 시스템 전체의 가용성을 결정한다.

     => 그래서 대부분 단일 장애점을 없애기 위해 이중화는 해둔다.



## 3. DB 서버의 다중화 - 클러스터링