# 3장. 컴퓨터 시스템의 동작 원리

> 운영체제를 이해하기 전에 우선적으로 알아두어야 할 컴퓨터 하드웨어의 구성 및 동작 원리를 살펴본다.
>
> 컴퓨터 내부장치인 CPU와 메모리에 대해 살펴보고, 컴퓨터 외부의 주변장치에 대해서도 간단히 살펴본다.

## 1. 컴퓨터 시스템의 동작 원리

> 컴퓨터 시스템 구조 = 컴퓨터 내부장치(CPU, 메모리) + 컴퓨터 외부장치(디스크, 키보드, 마우스, 네트워크 장치 등)

컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 그 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다. **=> 입력/출력**

메모리 및 입출력장치 등의 하드웨어 장치에는 `컨트롤러`라는 것이 붙어 있다. 컨트롤러는 각 하드웨어 장치마다 존재하면서 이들을 제어하는 작은 CPU다.

![](images/03_computer_structure.jpg)



## 2. CPU와 I/O 연산

입출력 장치들의 연산(**I/O 연산**)은 `입출력 컨트롤러`가 담당하고, 컴퓨터 내에서 수행되는 연산은 `메인 CPU`가 담당한다. 이때 입출력 장치와 메인 CPU는 동시 수행이 가능하다.

ex) B라는 프로그램이 현재 CPU를 할당받아 프로그램 코드를 수행하고, A라는 프로그램은 하드디스크에서 어떠한 정보를 읽어오는 작업을 수행해야 한다. 이러한 경우 두 가지 일이 다른 곳에서 발생하므로 동시에 수행되는 것이 가능함.

- 로컬버퍼(local buffer)

  : 장치 컨트롤러는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 **작은 메모리**를 가지고 있다. 이를 로컬버퍼라고 부른다.

  - 디스크나 키보드 등에서 데이터를 읽어오는 경우, 우선 로컬버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다. **이때 장치에서 로컬버퍼로 읽어오는 일은 컨트롤러가 담당한다.**

  - 이때 로컬버퍼로 읽어오는 작업이 다 끝났는지를 메인 CPU가 지속적으로 체크하는 것이 아니라 장치에 있는 컨트롤러가 `인터럽트`를 발생시켜 CPU에 보고하게 된다.
  
- 인터럽트(interrupt)

  : 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법.

  키보드 입력 혹은 요청된 디스크 입출력 작업의 완료 등 CPU에 알려줘야 하는 이벤트가 일어난 경우 컨트롤러가 발생시키는 신호다.

  - CPU는 메모리에서 명령(instruction)을 하나씩 읽어와서 수행하는데, 수행할 때마다 인터럽트가 발생했는지 확인한다.

    (CPU 옆에는 `인터럽트 라인(interrupt line)`이 있어서 그 곳을 통해 신호가 들어온다)

    - 인터럽트가 발생했으면 다음 명령을 수행하기 전에 인터럽트 처리를 함
    - 그렇지 않으면 다음 명령을 계속 수행



## 3. 인터럽트의 일반적 기능

운영체제 **커널**에는 인터럽트가 들어왔을 때 해야할 일이 미리 다 프로그래밍되어 그 코드(`인터럽트 처리루틴`)가 보관되어 있다.

1. `프로그램이 요청한 데이터`를 디스크 **컨트롤러가** 로컬버퍼에서 읽어온 후, **인터럽트를 발생시키면** CPU는 인터럽트가 들어옴을 인지하고 인터럽트 관련 업무(인터럽트 처리루틴)를 수행한다.
2. 이 때 수행하는 일은 **디스크의 로컬버퍼에 있는 내용**을 사용자 프로그램의 **메모리**로 전달하고, 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시해두는 일이다.

**[인터럽트 처리루틴]**

다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의한 것

``` java
운영체제의 기능
    1. 하드웨어 및 소프트웨어 자원 관리
    2. 사용자를 위한 편리한 환경(인터페이스) 제공
    3. 사용자 프로그램에 필요한 서비스 제공 => 인터럽트 처리루틴
```



**[인터럽트]**

CPU의 서비스가 필요한 경우, CPU 옆에 있는 **인터럽트 라인**에 신호를 보내서 인터럽트가 발생했음을 알려주는 방식은 둘 다 동일하다.

1. 하드웨어 인터럽트

   : `컨트롤러` 등 하드웨어 장치가 CPU의 인터럽트 라인을 set

2. 소프트웨어 인터럽트

   : 소프트웨어가 CPU의 인터럽트 라인을 set
   
   - 통상적으로 인터럽트라고 하면 하드웨어 인터럽트를 의미하고, 소프트웨어 인터럽트는 **트랩(trap)**이라는 용어로 주로 불린다.
   
   - 예로는 예외상황(exception)과 시스템 콜(system call)이 있다.
   
     - 예외상황
   
       : 사용자 프로그램이 비정상적인 작업을 시도하거나(0으로 나누기), 권한이 없는 작업을 시도할 때(자신의 메모리 영역 바깥에 접근하려는 시도)
   
     - 시스템 콜
   
       : 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법(키보드 입력이나 화면 출력 등의 입출력 작업)
   
   - **프로그램 코드가 직접 인터럽트 라인을 set하는 명령을 실행하여 인터럽트를 발생시킨다.** 그 후에는 CPU의 제어권이 사용자 프로세스로부터 운영체제로 넘어가게 된다.



운영체제는 인터럽트 코드를 쉽게 찾아가기 위해 **인터럽트 벡터(interrupt vector)**를 가지고 있다.

인터럽트 벡터란 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조를 말한다. 실제 처리해야 할 코드는 `인터럽트 처리루틴(interrupt service routine)` 또는 `인터럽트 핸들러(interrupt handler)`라고 불리는 다른 곳에 정의된다.



## 4. 인터럽트 핸들링

> 인터럽트 핸들링(interrupt handling)이란 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다.

1. 프로그램 A가 실행되고 있을 때 인터럽트가 발생하면 A의 **현재 상태를 PCB에 먼저 저장**한다.

   (현재 CPU에서 실행 중인 명령어의 메모리 주소 + 레지스터값 + 부가 정보)

   *CPU에서 명령이 실행될 때에는 CPU 내부에 있는 임시 기억장치인 레지스터(register)에 데이터를 읽거나 쓰면서 작업을 한다.

   - `프로세스 제어블록(Process Control Block: PCB)`

     : 운영체제가 현재 실행되는 프로그램들을 관리하기 위해 두는 자료구조

     PCB는 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행 중이었는지를 저장하고 있다.

2. **CPU의 제어권**이 인터럽트 처리 루틴으로 넘어간다.

3. 인터럽트 처리가 끝나면 저장된 상태를 **PCB**로부터 CPU상에 복원한다. 그러면 인터럽트 당하기 직전의 위치부터 실행이 이어지게 된다.

오늘날의 컴퓨터에서 운영체제는 인터럽트가 발생할 때에만 실행된다. 시스템이 **부팅** 후 정상 상태에 머무르게 되면 CPU가 항상 사용자 프로그램에 의해 사용되며, 인터럽트가 발생했을 때에만 운영체제가 잠깐 제어권을 흭득할 수 있기 때문이다.



## 5. 입출력 구조

> 입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 **데이터를 주고받는 것**을 말한다.

1. 동기식 입출력 (synchronous I/O)

   : 어떤 프로그램이 입출력 요청을 했을 때 **입출력이 완료된 후**에야 그 프로그램이 후속 작업을 수행할 수 있는 방식.

   입출력이 완료되어 인터럽트를 set하면 CPU의 제어권이 다시 그 프로그램에게 넘어가서 다음 명령을 수행할 수 있게 된다.

   1) CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 **자원을 낭비**하게 된다. **따라서 일반적으로 프로그램이 입출력을 수행하는 중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속 쉬지 않고 일할 수 있도록 관리한다.**

   - 이를 관리하기 위해 운영체제는 프로그램을 몇 가지 `상태`로 나누고 입출력 중인 프로그램의 경우 **봉쇄 상태(blocked state)**로 전환시킨다.

   - 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않는다.

   2) 입출력이 수행 중일 때 다른 프로그램에게 CPU를 양도하게 되므로 **다수의 입출력 연산이 동시에** 요청되거나 처리될 수 있다.

   ​	(새로 제어권을 갖게 된 프로그램 역시 입출력 요청을 할 수 있다)

   - 이 때 매 시점 2개 이상의 입출력 연산을 수행할 수 있다면, `컨트롤러`는 프로그램A와 프로그램B의 순서를 바꾸어 수행할 가능성이 있다. 즉 A가 입출력을 요청한 다음 B가 요청했다고 할 때, 컨트롤러는 작업을 바꿔서 B의 요청을 먼저 처리할 수 있다.

   - 따라서 동기식 입출력에서는 **입출력 요청의 동기화를 위해 장치별로 `큐(queue)`를 두어** 요청한 순서대로 처리할 수 있도록 한다.

     - 큐에 있는 순서대로 처리하는 대신, 요청들을 모으고 처리 순서를 바꾸어 입출력의 효율성을 높일 수도 있는데, 이러한 경우 동기화를 보장하기 위한 별도의 방안이 마련되어야 한다.

     <img src="images/03_queue.jpg" style="zoom:67%;" />

   3) 이때 CPU의 수행 속도에 비해 `컨트롤러`의 수행 속도나 `장치 자체의 작업 수행 능력`은 매우 떨어진다. 따라서 CPU가 입출력과 관련 없는 프로그램을 수행하도록 하고, 요청된 입출력 연산이 완료되면 CPU에게 알려준다.

   - 연산 완료의 통보는 **인터럽트**를 통해 수행되며, 운영체제 **커널**은 인터럽트 처리루틴으로 가서 입출력 연산을 끝낸 프로그램이 CPU를 할당받을 수 있도록 **봉쇄 상태를 해제**시킨다.

   ``` java
   => 입출력의 요청과 완료는 인터럽트 set을 통해 이루어진다.
   	(요청 - 사용자 프로그램이 시스템 콜을 통해 set명령어 직접 실행 - 소프트웨어 인터럽트
        완료 - 컨트롤러가 set	- 하드웨어 인터럽트)
   ```

   

2. 비동기식 입출력 (asynchronous I/O)

   : 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라, CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식

   - 프로그램이 데이터를 디스크에서 읽어오라는 요청을 하고, 그 데이터와 관련 없이 수행할 수 있는 일이 있을 수 있다. **비동기식 입출력에서는 그러한 작업을 먼저 수행하고, 읽어오는 데이터가 반드시 있어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다. => `무조건 동기화하지 않는 것이 아님!`**
   - 디스크에 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령을 수행할 수 있다.

   ``` java
   => 동기식과 마찬가지로 입출력의 요청과 완료는 인터럽트 set을 통해 이루어진다.
   ```

<img src="images/03_IO.jpg" style="zoom:67%;" />

일반적으로 운영체제에게 입출력 요청을 할 경우 해당 프로그램의 입출력이 완료될 때까지 그 프로그램을 봉쇄시키는 **동기식 입출력**을 사용한다.

- [동기식 입출력의 과정](동기식 입출력의 과정(Synchronous IO))