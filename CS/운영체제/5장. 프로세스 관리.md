# 5장. 프로세스 관리

> 컴퓨터 프로그램이 어떻게 수행되는지를 설명한다.
>
> 하나의 프로그램이 메모리에 올라가서 프로세스가 되면 CPU를 얻고 빼앗기는 과정을 반복하며 프로그램의 진행이 이루어지고, 최종적으로 자신이 할 일을 끝낸 후 종료하게 된다.
>
> 이와 같은 모습은 인간의 일생과 유사한 측면을 가지고 있으며, 프로세스가 운영체제의 지배를 받으며 수행되는 모습은 대단히 계획적이고 효율적인 사회 집단을 연상케 한다.
>
> 운영체제가 얼마나 효율적으로 프로세스를 관리하는지 이 장에서 자세히 살펴본다.

## 1. 프로세스의 개념

> 프로세스(process)란 **실행 중인 프로그램(program in execution)**을 뜻한다.

디스크에 `실행파일` 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 프로세스가 되며, 프로세스는 CPU를 획득해 자신의 코드를 수행하기도 하고, 때로는 CPU를 반환하고 입출력 작업을 수행하기도 한다. 그러다가 자신의 임무를 다 수행하고 나면 종료되어 사라지게 된다.

일반적으로 **잡(job)**이라는 용어와 프로세스를 혼용해 사용하기도 한다.

**[프로세스의 문맥(context)]**

프로세스의 문맥이란 **프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 `정보`**를 의미한다.

`시분할 시스템 환경`에서 타이머 인터럽트에 의해 CPU를 빼앗겼다가 추후에 다시 CPU를 획득해 명령의 수행을 재개하는 시점이 되면, 직전 수행 시점의 정확한 상태를 재현할 필요가 있다.

> 아래 3종류의 프로세스 문맥(정보) 모두 PCB에 저장된다.
>
> => 커널 스택도?? 스택 영역 아닌가 

- 하드웨어 문맥

  : CPU의 수행 상태를 나타내는 것. 프로그램 카운터값과 각종 레지스터에 저장하고 있는 값들을 의미한다.

- 프로세스의 주소 공간

  : 프로세스는 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소 공간을 가지고 있다.

- 커널상의 문맥

  : 프로그램이 수행되어 프로세스가 되면 운영체제는 프로세스를 관리하기 위한 자료구조를 유지한다.

  **PCB**와 **커널스택(kernel stack)**이 이에 해당한다.

  <img src="images/05_context.jpg" style="zoom:50%;" />



## 2. 프로세스의 상태

> 프로세스의 상태는 **실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)**의 세 가지로 구분할 수 있다.

<img src="images/05_state.jpg" style="zoom:50%;" />

- 실행 상태

  : 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태

- 준비 상태

  : 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태

- 봉쇄 상태

  : CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태

  ex) 프로세스가 요청한 입출력 작업이 진행 중인 경우

이 밖에 프로세스가 생성 중이거나 종료 중인 일시적 상태를 각각 **시작(new)** 상태, **완료(terminated)** 상태라고 부르기도 한다.

- 시작 상태

  : 프로세스가 시작되어 그 프로세스를 위한 각종 **자료구조**는 생성되었지만 아직 메모리 획득 권한??(HDD가 아니라)을 승인받지 못한 상태

  +승인받는 중인 상태

- 완료 상태

  : 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 **자료구조**를 완전히 정리하지 못한 상태

**[문맥 교환(context switch)]**

> 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 **과정**

문맥 교환이 일어나는 경우

1. 타이머 인터럽트가 발생하는 경우

   : `실행` 상태에서 CPU의 제어권을 가지고 프로세스가 실행되는 중에 **타이머 인터럽트**가 발생하면 CPU의 제어권은 운영체제로 이양된다.

   그러면 운영체제는 타이머 인터럽트 처리루틴으로 가서 수행 중이던 프로세스의 문맥을 저장하고,

    `준비` 상태에 있는 프로세스 중에서 새롭게 CPU의 제어권을 부여할 프로세스를 선택한다. **= CPU 디스패치**

   그러면 원래 수행 중이던 프로세스는 `준비` 상태로 변하고 새롭게 CPU를 할당받은 프로세스가 `실행` 상태가 된다.

2. 실행 상태에 있던 프로세스가 (입출력 요청 등으로) `봉쇄` 상태로 바뀌는 경우

   : 디스크 입출력 명령이 포함된 경우, 입출력이 완료될 때까지 CPU를 반환한 다음 디스크 입출력 서비스를 기다리며 `봉쇄` 상태로 바뀌게 된다.

   그러면 **CPU 스케줄러**가 CPU 디스패치를 진행한다. <- 디스패처가 따로 있는 것 아닌가?

   CPU는 다른 프로세스를 실행하고 있다가 입출력이 완료되어 디스크 컨트롤러가 인터럽트를 발생시킨 것을 확인하면 그에 대응하는 루틴을 수행한다.

   이 루틴이 진행되는 동안 CPU에서 수행되던 프로세스의 상태는 `사용자모드 실행 상태`에서 `커널모드 실행 상태`로 바뀐다. 비록 인터럽트 처리루틴이 직전에 실행 중이던 프로세스와는 무관한 업무를 담고 있지만, ***편의상* 인터럽트 처리를 직전 프로세스의 문맥에서 실행된 것으로 간주한다.**

   <img src="images/05_interrupt_stack.JPG" style="zoom:80%;" />
   
   > 다시 말해 프로세스가 실행되던 중에 인터럽트가 발생하면, 인터럽트가 발생한 원인과 관계 없이 인터럽트를 당한 프로세스가 사용자모드에서 실행되다가 커널모드로 진입한 것으로 *간주하게 된다*는 것이다.
   
   디스크 컨트롤러가 발생시킨 인터럽트는 입출력이 완료된 프로세스의 상태를 `봉쇄` 상태에서 `준비` 상태로 바꾼 후 장치의 **로컬버퍼에 있는 내용을 메모리로 이동**시키는 업무를 수행한다.
   
   이렇게 인터럽트 처리가 끝나면 인터럽트 처리루틴 이전에 수행되던 프로세스의 코드가 실행되거나, 일반적인 경우는 아니지만 입출력이 완료된 프로세스가 더 우선순위가 높은 경우 **문맥교환**을 통해 CPU 제어권을 이양시킬 수도 있다.

문맥 교환이 일어날 때, `준비` 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 CPU의 제어권을 넘겨받는 과정을 **CPU 디스패치(dispatch)**라고 한다.

 *dispatch = 빠르게 발송하다

<img src="images/05_CPU_dispatch.JPG" style="zoom:80%;" />

> 단 하나 예외로, 맨 처음 생성되는 프로세스는 문맥교환 없이 CPU 디스패치 된다??



## 3. 프로세스 제어블록

> 프로세스 제어블록(Process Control Block: PCB)이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 **프로세스마다 유지하는 정보들을 담는 `커널 내의 자료구조`**를 뜻한다.

PCB는 다음과 같은 요소들로 구성되어 있다.

- 프로세스의 상태(process state)

  : CPU를 할당해도 되는지 여부를 결정하기 위해 필요

- 프로그램 카운터(program counter)의 값

  : 다음에 수행할 명령의 위치를 가리킴

- CPU 레지스터(CPU register)의 값

  : CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타냄

- CPU 스케줄링 정보(CPU scheduling information)

  : 프로세스의 CPU 스케줄링을 위해 필요한 정보

- 메모리 관리 정보(memory management information)

  : 프로세스의 메모리 할당을 위해 필요한 정보

- 자원 사용 정보(accounting information)

  : 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용됨

- 입출력 상태 정보(I/O status information)

  : 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보를 나타냄

<img src="images/05_PCB.jpg" style="zoom:50%;" />



## 4. 문맥교환

> 문맥교환(context switch)이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.

문맥교환이 일어나는 경우

<img src="images/05_switching.jpg" style="zoom:50%;" />

- 타이머 인터럽트가 발생하거나
- 프로세스가 **입출력 요청** 시스템 콜(=SW 인터럽트)을 하여 `봉쇄` 상태에 들어가는 경우.
  - 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터값 등 `프로세스의 문맥을 자신의 PCB에 저장`하고, 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원시킨다.
  - 모드 변경에 비해 훨씬 많은 오버헤드(overhead)가 발생한다.

문맥교환이 일어나지 않는 경우

<img src="images/05_switching2.jpg" style="zoom:60%;" />

- 입출력 요청 외의 시스템 콜이나 인터럽트가 발생하는 경우.

  - 문맥교환이 일어나지 않고 **실행 모드만이 변경**된다.

  - 이 경우에도 CPU의 실행 위치 등 `프로세스의 문맥 중 일부를 PCB에 저장`하게 되지만, **이러한 과정을 문맥교환이라고 하지는 않는다.**

    <u>하나의 프로세스</u>의 실행모드만이 사용자모드 -> 커널모드로 바뀌는 것일 뿐, CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 때문이다.

문맥교환 중에 일어나는 작업이 실제 시스템에 유용한 작업이 아니기 때문에, 문맥교환에 소요되는 시간은 시스템 입장에서 볼 때 일종의 오버헤드라고 할 수 있다. 따라서 적절한 CPU 할당시간을 정하는 것이 중요하다.



## 5. 프로세스를 스케줄링하기 위한 큐

> 운영체제는 **특정 자원을 기다리는 프로세스들을 줄 세우기 위해** 자원별로 큐(queue)를 둔다.

<img src="images/05_queue2.jpg" style="zoom:50%;" />

프로세스의 `상태` 관리는 **커널의 주소 영역 중 `데이터 영역`**에 다양한 큐(queue)를 두어 수행하게 된다.

각 프로세스가 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 `커널`이 총체적으로 관리한다는 뜻이다.

- 예를 들어 타이머 인터럽트가 발생하면 커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해 다음에 어느 프로세스에게 CPU를 할당할지 결정하고, 현재 실행 중인 프로세스는 준비 큐의 제일 뒤로 보낸다.

<img src="images/05_queue.jpg" style="zoom:60%;" />

준비 큐에 속한 프로세스들은 `준비` 상태에 있고, 장치 큐에 속한 프로세스들은 `봉쇄` 상태에 있으므로 프로세스는 상태 변화에 따라 준비 큐와 장치 큐를 오가며 실행된다.

- 준비 큐(ready queue)

  : 운영체제는 `준비` 상태에 있는 프로세스들을 줄 세우기 위해 **준비 큐(ready queue)**를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다.

  준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다.

- 장치 큐(device queue)

  : **하드웨어 자원**을 기다리는 프로세스들을 줄 세우기 위해 필요한 큐. 자원별로 장치 큐를 둔다. 
  
  - 예를 들어 디스크에 입출력 서비스를 요청한 프로세스들은 디스크 입출력 큐(disk I/O queue)에 줄 서게 된다.
  
    그러면 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행한다.
  
  - 작업이 완료되면 디스크 컨트롤러가 CPU에 인터럽트를 발생시키게 되고, **그러면 인터럽트 처리루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 준비 큐에 줄 서게 된다.**
  
- 자원 큐

  접근 = 권한

  : **소프트웨어 자원**을 기다리는 프로세스들을 줄 세우기 위해 필요한 큐.

  - 예를 들어 `공유 데이터에 대한 접근 권한`(공유 데이터 자체가 아님)이 있다. 

    공유 데이터는 일관성을 위해 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다.

  - 이때 '접근한다'는 것이 반드시 CPU가 **그 데이터를 사용하고 있음을 의미하는 것은 아니다**(접근 권한을 할당받았으므로).

    공유 데이터에 접근 중인 프로세스가 `준비` 상태나 `봉쇄` 상태로 변경된 경우에도 새롭게 CPU를 할당받은 프로세스가 동일한 데이터에 접근하게 되면 데이터의 일관성이 깨질 수 있으므로 접근을 허락해서는 안된다. = 접근 권한이 없다.
  
  - 따라서 여러 프로세스가 공유 데이터에 동시에 접근하려고 할 경우 공유 데이터를 기다리는 큐에 줄 서게 하여, 현재 그 데이터를 사용하고 있는 프로세스가 데이터를 반납하기 전까지는 접근하지 못하게 한다.

작업 큐가 가장 넓은 개념이고 준비 큐와 장치 큐에 있는 프로세스들은 모두 작업 큐에 속해 있다.

- 작업 큐(job queue)

  : 시스템 내의 모든 프로세스를 관리하기 위한 큐로, **프로세스의 상태와 무관**하게 현재 시스템 내에 있는 *모든 프로세스*가 작업 큐에 속하게 된다. 

<img src="images/05_queue_structure.jpg" style="zoom:50%;" />

위의 그림은 운영체제가 다양한 큐를 어떻게 자료구조로 구현하는지 보여준다.

- 큐헤더(queue header)는 큐의 가장 앞부분을 말한다.

- 큐는 각 프로세스의 `PCB`를 **연결 리스트** 형태로 관리하며 포인터를 사용해 순서를 정한다. 



## 6. 스케줄러

> 스케줄러(scheduler)란 어떤 프로세스에게 자원을 할당할지를 결정하는 **운영체제 커널의 코드**를 지칭한다.

- 장기 스케줄러(long term scheduler)

  : `작업 스케줄러(job scheduler)`라고도 부르며, 어떤 프로세스를 **준비 큐**에 진입시킬지 `결정`하는 역할을 한다.

  처음 프로세스가 생성되면 `시작` 상태를 거쳐 `준비` 상태에 이르게 되는데 장기 스케줄러는 이때 시작 상태의 프로세스들 중 어떠한 프로세스를 준비 큐에 삽입할 것인지 결정하는 역할을 한다.

  - 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 속도가 느린 것이 허용됨

- 단기 스케줄러(short term scheduler)

  : `CPU 스케줄러`라고도 하며, `준비` 상태의 프로세스 중에서 어떤 프로세스를 다음번에 `실행` 상태로 만들 것인지 결정한다.

  시분할 시스템에서 **타이머 인터럽트**가 발생하면 단기 스케줄러가 호출되고, **준비 큐**에 있는 여러 프로세스들 중 어떠한 프로세스에게 CPU를 할당할 것인가를 단기 스케줄러가 결정한다.

  - 밀리초 정도의 단위로 매우 빈번하게 호출되기 때문에 속도가 빨라야 함

장기 스케줄러는 메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)를 조절하는 역할을 한다. 이는 시작 상태의 프로세스에게 **메모리 할당을 승인**할지 여부를 장기 스케줄러가 결정하기 때문이다.

> 그러나 현대의 시분할 시스템에서 사용되는 운영체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분이다.
>
> 과거에는 적은 양의 메모리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 지나치게 적어져 시스템의 효율이 매우 떨어졌기 때문에 장기 스케줄러가 이를 조절하는 역할을 담당했다.
>
> 현대에는 프로세스가 `시작` 상태가 되면 장기 스케줄러 없이 곧바로 그 프로세스에 메모리를 할당해 **준비 큐**에 넣어준다.

현대의 시분할 시스템용 운영체제에서는 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다.

- 중기 스케줄러(medium term scheduler)

  : 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 **동적으로 조절**한다.

  - 프로세스당 보유하고 있는 메모리양이 극도로 적어지면 CPU 수행에 당장 필요한 `프로세스의 주소공간(코드, 데이터, 스택)`조차도 메모리에 올려놓기 어려운 상황이 발생한다.

    그렇게 되면 *디스크의 입출력이 수시로 발생하게 되어* 시스템의 성능이 심각하게 저하될 수 있다.

  - **[스왑 아웃(swap out)]**

    : 일부 프로세스를 메모리에서 통째로 옮겨 `디스크의 스왑 영역`에 저장시킨다. 
    
    - 0순위 - `봉쇄` 상태 프로세스
    
      (봉쇄 상태인 프로세스들은 당장 CPU를 획득할 가능성이 없기 때문에 메모리를 보유하고 있는 것 또한 큰 의미가 없기 때문)
    
    - 1순위 - 타이머 인터럽트가 발생해 `준비 큐`로 이동하는 프로세스

중기 스케줄러의 등장으로 인해 프로세스의 상태에는 `실행`, `준비`, `봉쇄` 외에 하나의 상태가 더 추가된다.

- `중지(suspended, stopped)` 상태

  : **외부적인 이유**로 프로세스의 수행이 정지된 상태.

  중지 상태에 있는 프로세스는 외부에서 재개시키지 않는 이상 다시 활성화될 수 없으므로 메모리 자원이 당장 필요하지 않다. 따라서 메모리를 보유하지 않고 디스크로 통째로 **스왑 아웃**된다.

  - 중지준비(suspended ready) 상태 (1순위로 스왑아웃 된 프로세스)

    : `준비` 상태에 있던 프로세스가 **중기 스케줄러**에 의해 디스크로 **스왑 아웃**된 상태

  - 중지봉쇄(suspended block) 상태 (0순위로 스왑아웃 된 프로세스) 

    : `봉쇄` 상태에 있던 프로세스가 **중기 스케줄러**에 의해 디스크로 **스왑 아웃**된 상태

    => 봉쇄되었던 조건을 만족하게 되면 `중지준비` 상태로 바뀐다.

<img src="images/05_state2.jpg" style="zoom:60%;" />



## 7. 프로세스의 생성

> 시스템이 부팅된 후 최초의 프로세스는 운영체제가 **직접 생성**하지만, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 **복제 생성**하게 된다.

이때 프로세스를 생성한 프로세스를 `부모 프로세스`라고 하고, 새롭게 생성된 프로세스를 `자식 프로세스`라고 한다.

프로세스의 세계는 인간의 세계와 상당한 차이가 있다. 프로세스의 세계에서는 자식이 먼저 죽고, 이에 대한 처리는 자식을 생성했던 부모 프로세스가 담당하는 방식으로 진행된다.

- 생성된 프로세스가 작업을 수행하기 위해서는 자원이 필요하다. 자원을 획득하는 방법은 운영체제 및 자원의 종류에 따라 상이하다.

  1. 운영체제로부터 직접 자원을 할당받음
  2. 부모 프로세스와 자원을 공유해서 사용

- 프로세스가 수행되는 모델에 따라서도 자원을 획득하는 방법이 달라진다.

  1. 부모와 자식이 공존하며 수행되는 모델

     : 자식과 부모가 CPU를 획득하기 위해 경쟁하는 관계

  2. 자식이 `종료(terminate)`될 때까지 부모가 `기다리는(wait)` 모델

     : 자식 프로세스가 종료될 때까지 부모 프로세스는 `봉쇄(blocked, wait)` 상태에 머물러 있다가, 자식 프로세스가 종료되면 `준비` 상태가 되어 다시 CPU를 얻을 권한이 생긴다.

<img src="images/05_process.jpg" style="zoom:50%;" />

프로세스가 생성되면 **자신만의 독자적인 주소공간(address space)**을 갖게 된다.

> 부모 프로세스가 자식 프로세스를 생성하면, 처음 주소 공간(코드, 데이터, 스택)을 생성할 때에 **부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성**한다.
>
> 자식 프로세스가 다른 프로그램을 수행하기 위해서는 **생성된 주소 공간 위에 새로운 프로그램의 주소 공간을 덮어씌워** 실행하게 되는 것이다.

**[유닉스의 예]**

- 유닉스에서는 `fork()` 시스템 콜을 통해 새로운 프로세스를 생성할 수 있다.

  fork() 시스템 콜은 자식 프로세스를 생성할 때, 프로세스 ID를 제외한 부모 프로세스의 모든 정보(운영체제 커널 내의 정보와 주소 공간의 정보)를 그대로 복사하는 방법을 사용한다.

- `exec()` 시스템 콜을 통해 새로운 프로그램으로 주소 공간을 덮어씌울 수 있다.

- 유닉스 시스템의 프로세스 계층도

  <img src="images/05_UNIX.jpg" style="zoom:50%;" />

  - 원칙적으로 부모 프로세스가 종료되기 전에 그 아래에 존재하는 모든 자식 프로세스들이 먼저 종료되어야 한다.

  - 프로세스의 종료

    1. 자발적 종료

       : 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알린 뒤 종료한다.

       프로세스는 명령을 모두 수행한 후, 프로그램이 마쳐지는 코드 부분에 `exit()`라는 시스템 콜을 넣어주도록 되어있다. **(컴파일러가 자동으로 삽입)**

    2. 비자발적 종료

       : 부모 프로세스가 자식 프로세스의 수행을 강제로 종료시킨다.

       `abort()` 함수를 통해 이루어진다.

       - 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구할 때

       - 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때

       - 부모 프로세스가 종료(exit)되는 경우 등

         (종료되지 않을 다른 프로세스의 **양자**로 자식 프로세스를 보내어, 기존 부모가 종료된 후에도 다른 프로세스 아래에서 계속 수행될 수 있도록 할 수 있다)

- [자식 프로세스 생성 과정](자식%20프로세스%20생성%20과정.md)



## 8. 프로세스 간의 협력

> 프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며, 프로세스가 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다.
>
> 따라서 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.

그러나 경우에 따라서는 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있으므로, 운영체제는 **프로세스 간의 협력 메커니즘**을 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있게 한다.

- IPC (Inter-Process Communication: 인터프로세스 커뮤니케이션)

  : 프로세스 간의 협력 메커니즘을 위해 운영체제가 제공하는 대표적인 메커니즘으로, 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신을 말한다.



