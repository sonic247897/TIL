# 7장. 메모리 관리

> 프로그램이 실행되기 위해서는 실행에 당장 필요한 부분이 **메모리**에 올라가 있어야 한다.
>
> 여러 프로그램이 동시에 실행되는 환경에서는 한정된 메모리 공간을 여러 프로그램이 조금씩 나누어 사용해야 한다.
>
> 이때 어떤 프로그램에 어느 정도의 메모리를 할당할 것인가를 결정해야 한다.
>
> - 운영체제는 모든 프로그램에게 공평하게 메모리를 할당하기보다는 **몇몇 프로그램에게 집중적으로 메모리를 할당**한 후, 시간이 흐르면 이들로부터 메모리를 회수하여 또 다른 프로그램에게 집중적으로 메모리를 할당하는 방식을 채택한다.
> - 이런 방식을 채택하는 이유는 프로그램의 빠른 실행을 위해 프로그램마다 적어도 일정 수준 이상의 메모리 공간을 확보하고 있는 것이 효율적이기 때문이다.

메모리는 `주소`를 통해 접근하는 저장장치이다.

이때의 주소(address)란 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자로 구성된다.

컴퓨터는 이진수를 사용하므로 **메모리 주소는 이진수**로 매겨지게 된다.

- 흔히 사용하는 컴퓨터 시스템은 32비트 혹은 64비트의 주소 체계를 사용하고 있다.

- 컴퓨터에서는 **`byte` 단위로 메모리 주소를 부여**한다.

  - ex) 32비트 주소 체계

    : 2^32 `바이트`만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.

컴퓨터상의 주소도 32비트를 그대로 사용하지 않고 효율적인 운영을 위해 연속된 일련의 영역을 행정구역처럼 묶어서 사용한다. 즉, 주소를 숫자로만 구분하지 않고 계층적으로 나누어 관리한다.

- 페이지(page)

  : 보통 4 KB(= 2^12 byte) 단위로 묶어서 `페이지`라는 행정구역(계층)을 만든다.

   페이지 하나의 크기가 2^12 바이트이므로 페이지 내에서 바이트별 위치 구분을 위해서는 12비트가 필요하다.

  따라서 총 32비트의 주소 중 **하위 12비트는 페이지 내에서의 주소**를 나타내게 된다.

## 1. 주소 바인딩

- 프로세스의 주소 공간(address space)

  : 프로그램이 실행을 위해 **메모리**에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성된다.

  이 주소를 `논리적 주소(logical address)` 혹은 `가상 주소(virtual address)`라고 부른다.

  > CPU는 **논리적 주소(가상 주소)에 근거해 `기계어 명령`을 실행**한다.
  >
  > 논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.

- 물리적 주소(physical address)

  : 물리적 메모리에 실제로 올라가는 위치

  - 낮은 주소 영역 - 운영체제가 올라감
  - 높은 주소 영역 - 사용자 프로세스들이 올라감

CPU가 `기계어 명령`을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되면, 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.

- 주소 바인딩(address binding)

  : 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업

**[주소 바인딩의 방식]**

프로그램이 적재되는 **물리적 메모리의 주소가 결정되는 시기**에 따라 세 가지로 분류할 수 있다.

1. 컴파일 타임 바인딩(compile time binding)

   : 물리적 메모리 주소가 **프로그램을 컴파일 할 때 결정**되는 주소 바인딩 방식

   **프로그램이 `절대주소`로 적재된다**는 뜻에서 `절대코드(absolute code)`를 생성하는 바인딩 방식이라고 말하기도 한다.

   - 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶다면 컴파일을 다시 해야한다.
   - 따라서 비현실적이고 현대의 시분할 컴퓨팅 환경에서는 잘 사용하지 않는다.

2. 로드 타임 바인딩(load time binding)

   : **프로그램의 `실행(running)`이 시작될 때에 물리적 메모리 주소가 결정**되는 주소 바인딩 방식

   `로더(loader)`의 책임하에 물리적 메모리 주소가 부여되며, **프로그램이 `종료(terminated)`될 때까지 물리적 메모리 상의 위치가 고정**된다.

   - 로더 - 사용자 프로그램을 메모리에 적재시키는 프로그램
   - 컴파일러가 `재배치 가능 코드(relocatable code)`를 생성한 경우에 가능한 주소 바인딩 방식이다.

3. 실행시간 바인딩(execution time binding 또는 run time binding)

   : 프로그램이 `실행(running)`을 시작한 후에도 그 프로그램이 위치한 **물리적 메모리 상의 주소가 변경될 수 있는** 바인딩 방식

   CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, `주소 매핑 테이블(address mapping table)`을 이용해 바인딩을 점검해야 한다.

   - 다른 방식들과 달리 하드웨어적인 지원이 필요

     - 기준 레지스터(base register)

     - 한계 레지스터(limit register)

     - MMU(Memory Management Unit: 메모리 관리 유닛)

       : 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치

**[MMU 기법(MMU scheme)]**

MMU를 사용해 가장 기본적인 방식으로 `주소 변환`을 수행하는 기법

- CPU가 특정 프로세스의 **논리적 주소**를 참조하려고 할 때, MMU 기법은 **그 주소값에 기준 레지스터의 값을 더해** 물리적 주소값을 얻어낸다.

  - 기준 레지스터

    : **프로세스의 물리적 메모리 시작 주소**를 가지고 있으며, `재배치 레지스터(relocation register)`라고도 부른다.

> `MMU 기법`이 **프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정**하기 때문에, 물리적 메모리 상의 시작 주소만 알면 주소 변환을 위와 같이 매우 쉽게 할 수 있는 것이다.

MMU 기법에서 `사용자 프로그램`이나 `CPU`는 **논리적 주소만을 다룰 뿐**, 실제 물리적 주소는 알지 못하며 알아야 할 필요도 없다.

<img src="images/07_MMU.jpg" style="zoom:50%;" />

이 그림에서 논리적 주소 123번지는 물리적 메모리의 시작 위치인 `재배치 레지스터`값으로부터 요청된 위치가 얼마나 떨어져 있는지를 나타내는 **일종의 오프셋(offset) 개념**으로 생각할 수 있다.

흔히 사용하는 `다중 프로그래밍 환경`에서 고려해야 할 사항이 있다. 하나의 주소 체계를 가지는 물리적 메모리 내에 **여러 프로세스가 동시에 올라가 있으므로** 다음 두 가지 사항을 고려한다.

1. MMU 기법에서는 `문맥교환`으로 CPU에서 수행 중인 프로세스가 바뀔 때마다 **재배치 레지스터의 값을 그 프로세스에 해당되는 값으로 재설정함**으로써 각 프로세스에 맞는, 서로 다른 123번지 위치에 접근하는 것을 지원한다.

2. CPU가 요청한 논리적 주소값과 재배치 레지스터 값을 더한 결과가 **해당 프로세스의 주소 공간을 벗어나는 경우**가 발생할 수 있다. 

   이렇게 되면 `메모리 보안(memory protection)`이 이루어지지 않아 다른 사람이 수행 중인 프로그램 영역을 침범하거나 심지어 운영체제 영역을 변경할 수도 있다.

   => 운영체제는 이러한 상황이 발생하는 것을 방지하기 위해 `한계 레지스터(limit register)`라는 또 하나의 레지스터를 사용한다.

   - 한계 레지스터는 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용되며,
   - 현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최대값, 즉 그 프로세스의 크기를 담고 있다.

   <img src="images/07_limit_register.jpg" style="zoom:50%;" />

   [메모리 보안을 달성하는 방법]

   먼저 CPU가 요청한 프로세스의 논리적 주소값이 한계 레지스터 내에 저장된 그 프로세스의 크기보다 작은지 확인한다.

   - 작다면 물리적 주소값을 구한 다음 해당 **물리적 메모리 위치에 접근하도록 허락**한다.
   - 크다면 프로세스가 존재하는 물리적 메모리의 바깥 부분에 접근하려는 시도이므로 `트랩`을 발생시켜 **해당 프로세스를 강제종료**시킨다.



## 2. 메모리 관리와 관련된 용어

### 1) 동적 로딩

동적로딩(dynamic loading)은 여러 프로그램이 동시에 메모리에 올라가서 수행되는 `다중 프로그래밍(multi-programming)` 환경에서 **메모리 사용의 효율성을 높이기 위해 사용하는 기법** 중 하나이다.

지금까지 우리는 프로세스를 실행시키기 위해 그 프로세스의 주소 공간 전체가 메모리에 적재되는 환경을 가정했다. (ex. MMU 기법)

하지만 동적로딩에서는 해당 부분이 불릴 때 그 부분만을 메모리에 적재하는 방식을 사용한다. 즉 프로세스 내에서 **실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재**하는 것을 말한다.

- 실제로 프로그램의 코드 중 상당 부분은 오류 처리루틴과 같이 아주 특별한 경우에만 가끔씩 사용되는 `방어용 코드`이다.

  동적로딩 기법은 사용되지도 않을 많은 양의 코드가 메모리에 올라가는 것을 막아 메모리를 좀 더 효율적으로 사용할 수 있도록 한다.

- 