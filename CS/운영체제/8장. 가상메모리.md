# 8장. 가상메모리

> 프로그램이 실행되기 위해서는 실행에 당장 필요한 부분이 **메모리**에 올라가 있어야 한다.
>
> 여러 프로그램이 동시에 실행되는 `시분할 환경`에서는 한정된 메모리 공간을 여러 프로그램이 조금씩 나누어 사용해야 한다.
>
> 따라서 `운영체제`는 어떤 프로그램에 어느 정도의 메모리를 할당할 것인가를 결정해야 한다.
>
> - 운영체제는 모든 프로그램에게 공평하게 메모리를 할당하기보다는 **몇몇 프로그램에게 집중적으로 메모리를 할당**한 후, 시간이 흐르면 이들로부터 메모리를 회수하여 또 다른 프로그램에게 집중적으로 메모리를 할당하는 방식을 채택한다.
> - 이런 방식을 채택하는 이유는 프로세스의 빠른 수행을 위해 프로그램마다 최소한 확보해야 하는 메모리의 크기가 존재하기 때문이다.

메모리의 연장 공간으로 **디스크의 스왑 영역**이 사용될 수 있기 때문에 프로그램 입장에서는 물리적 메모리 크기에 대한 제약을 생각할 필요가 없어진다.

나아가 `운영체제`는 프로그램이 물리적 메모리를 고려할 필요 없이 **자기 자신만이 메모리를 사용하는 것처럼 가정해 프로그램하는 것을 지원**한다.

=> 이렇게 되면 프로그램은 0번지부터 시작하는 자기 자신만의 메모리 주소 공간을 가정할 수 있는데, 이러한 메모리 공간을 `가상메모리(virtual memory)` 라고 부른다.

- 가상메모리 기법

  : **`프로세스의 주소 공간`을 메모리에 적재하는 단위에 따라** `요구 페이징(demand paging) 방식`과 `요구 세그먼테이션(demand segmentation) 방식`으로 구현될 수 있다.

  > 대부분의 경우에는 **요구 페이징 방식**을 사용하며, **요구 세그먼테이션 방식**을 사용하는 경우는 대개 **페이지드 세그먼테이션 기법**을 사용하는 경우이다.
  >
  > => 즉 세부적인 구현에서는 **요구 페이징** 기법만이 사용된다고 할 수 있다.

## 1. 요구 페이징

요구 페이징이란 프로그램 `실행` 시 프로세스를 구성하는 모든 페이지를 한꺼번에 `메모리`에 올리는 것이 아니라, **당장 사용될 페이지만을 올리는 방식**을 말한다.

따라서 요구 페이징 기법에서는 특정 페이지에 대해 `CPU의 요청`이 들어온 후에야 해당 페이지를 메모리에 적재한다.

나머지 페이지는 `디스크의 스왑 영역`에 존재한다.

- 장점
  - 메모리 사용량 감소
  - 프로세스 전체를 메모리에 올리는 데 소요되는 입출력 오버헤드 감소
  - 응답시간 단축
  - 시스템이 더 많은 프로세스를 수용할 수 있음
  - **물리적 메모리의 용량보다 큰 프로그램도 실행 가능**



- 유효-무효 비트(valid-invalid bit)

  : 요구 페이징에서는 `유효-무효 비트`를 두어 각 페이지가 메모리에 존재하는지 표시하게 된다.

  이 비트는 각 프로세스를 구성하는 모든 페이지에 대해 존재해야 하므로 페이지 테이블의 각 `항목`별로 저장된다.

  1. 프로세스가 `실행`되기 전 

     : 모든 페이지의 `유효-무효 비트`가 **무효값**으로 초기화 됨

  2. 특정 페이지가 참조되어 메모리에 적재되는 경우

     : 해당 페이지의 `유효-무효 비트`는 **유효값**으로 바뀜

  3. 메모리에 적재되어 있던 페이지가 디스크의 스왑 영역으로 쫓겨날 때

     : `유효-무효 비트`가 다시 **무효값**으로 바뀜

- `유효-무효 비트`의 값이 **무효**인 경우
  
  1. 페이지가 현재 메모리에 없는 경우
  2. 그 페이지가 속한 주소 영역을 프로세스가 사용하지 않는 경우(방어용 코드)

<img src="images/08_valid_bit.jpg" style="zoom:50%;" />

> **CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아** `유효-무효 비트`가 **무효**로 세팅되어 있는 경우를 '**페이지 부재(page fault)**'가 일어났다고 말한다.

### 1) 요구 페이징의 페이지 부재 처리

<img src="images/08_page_fault.jpg" style="zoom:50%;" />

CPU가 무효 페이지에 접근하면 **주소 변환을 담당하는 하드웨어인 `MMU`**가 `페이지 부재 트랩(page fault trap)`을 발생시키게 된다.

- `트랩`은 SW 인터럽트이다.

그러면 CPU의 제어권이 `커널모드`로 전환되고, 운영체제의 `페이지 부재 처리루틴(page fault handler)`이 호출되어 다음과 같은 순서로 페이지 부재를 처리한다.

1. 운영체제는 해당 페이지에 대한 접근이 적법한지를 먼저 체크한다.

   - 사용되지 않는 주소 영역에 속한 페이지에 접근

   - 해당 페이지에 대한 접근 권한 위반(protection violation)

     - ex) 읽기전용인 페이지에 대해 쓰기 접근 시도

     => 위 두 가지 경우에 대해서는 해당 프로세스를 `종료`시킨다.

2. 물리적 메모리에서 비어 있는 프레임(free frame)을 `할당`받아 그 공간에 해당 페이지를 읽어온다.

   - 만약 비어 있는 프레임이 없다면 기존에 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아낸다. (`스왑 아웃`)

   > 요청된 페이지를 디스크로부터 메모리로 적재하기까지는 오랜 시간이 소요된다. (<u>디스크 입출력</u>)
   >
   > 따라서 **페이지 부재를 발생시킨 프로세스**는 CPU를 빼앗기고 `봉쇄` 상태가 된다.
   >
   > - CPU 레지스터 상태 및 프로그램 카운터값은 PCB에 저장한다.

3. <u>디스크 입출력</u>이 완료되어 `인터럽트`가 발생하면 페이지 테이블에서 해당 페이지의 `유효-무효 비트`를 **유효**로 설정하고, `봉쇄`되었던 프로세스를 `준비 큐`로 이동시킨다.

4. 프로세스가 다시 CPU를 할당받으면 PCB에 저장해두었던 값을 복원시켜 이전에 중단되었던 `명령(instruction)`부터 실행을 재개한다.

   - `페이지 부재 트랩`을 발생시켰던 페이지에 위치한 명령이다.

### 2) 요구 페이징의 성능

요구 페이징 기법의 성능에 가장 큰 영향을 미치는 요소는 **페이지 부재의 발생 빈도**이다.

`페이지 부재`가 일어나면 **요청된 페이지를 디스크로부터 메모리로 읽어오는 막대한 오버헤드**가 발생하기 때문이다. **=> 디스크 입출력**

> 즉 페이지 부재가 적게 발생할수록 요구 페이징의 성능은 향상될 수 있다.

요구 페이징의 성능은 요청한 페이지를 참조하는데 걸리는 `유효 접근시간`으로 측정한다.

- 유효 접근시간(effective access time)

  = (1-P) * <u>메모리 접근시간</u> 

  ​	\+ P * (페이지 부재 발생 처리 오버헤드 + 메모리에 빈 프레임이 없는 경우 `스왑 아웃` 오버헤드 + 요청된 페이지의 `스왑 인` 오버헤드 + 프로세스의 재시작 오버헤드)

  - 메모리 접근시간

    : 페이지 부재가 발생하지 않으면, TLB 접근시간과 메모리에 적재되어 있는 페이지 테이블과 실제 데이터에 접근하는 시간 등이 고려된다.

  - 페이지 부재 발생 처리 오버헤드

    : `페이지 부재 트랩`을 발생시키고 `커널모드`로 전환해 처리루틴 호출 - 해당 페이지에 대한 접근이 적법한지 확인

  - 스왑 아웃 ~ 스왑 인

    : 메모리에 올라와 있는 페이지 중 하나의 페이지를 선택해 디스크로 `스왑 아웃`시킨 후**(교체 알고리즘)**, 스왑 영역에서 요청된 페이지를 메모리로 읽어와야 한다.

    - 스왑 아웃된 페이지와 스왑 인 되는 페이지의 `페이지 테이블`에서의 `유효-무효 비트` 값도 갱신해줘야 한다.

  - 프로세스의 재시작 오버헤드

    : 페이지를 다 읽어왔으면 `인터럽트`를 통해 프로세스가 실행을 재개할 수 있는 상태로 바꿔주고, 자신의 차례가 되면 `문맥교환`을 통해 다시 CPU를 얻을 수 있게 한다.

- 페이지 부재 발생비율(page fault rate) P

  - P = 0: 페이지 부재가 한 번도 일어나지 않은 경우
  - P = 1: 모든 참조 요청에서 페이지 부재가 발생한 경우

  => 페이지 부재가 발생하면 **디스크 입출력**과 **각종 오버헤드**가 포함되어 시간이 오래 걸리므로 P가 0에 가까울 수록 `페이징 기법`의 성능이 향상된다.



## 2. 페이지 교체

- 페이지 교체(page replacement)

  : `페이지 부재`가 발생하여 요청된 페이지를 디스크에서 메모리로 읽어올 때, 물리적 메모리에 **빈 프레임이 존재하지 않을 수 있다**.

  이 경우에 **`스왑 아웃`으로 메모리에 빈 공간을 확보하는 작업**을 `페이지 교체`라고 한다.

- 교체 알고리즘(replacement algorithm)

  : 페이지를 교체할 때 어떠한 프레임에 있는 페이지를 쫓아낼 것인지 결정하는 알고리즘

  > 이 알고리즘의 `목표`는 **페이지 부재율을 최소화**하는 것이다.
  >
  > => `가까운 미래`에 참조될 가능성이 가장 적은 페이지를 선택해서 내쫓는 것이 성능을 향상시킬 수 있는 방안이다.

  <img src="images/08_page_replacement.jpg" style="zoom:50%;" />

  - 페이지 교체 알고리즘의 성능 평가

    : 주어진 페이지 참조열(page reference string)에 대해 `페이지 부재율`을 계산한다.

    - 페이지 참조열 - 참조되는 페이지들의 번호를 **시간 순서**에 따라 나열한 것
      - ex) 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

    - 메모리에서 적중(hit) - 해당 번호의 페이지가 메모리에 이미 올라와 있음
    - 페이지 부재가 발생 - 해당 번호의 페이지가 메모리에 없음

### 1) 최적 페이지 교체

