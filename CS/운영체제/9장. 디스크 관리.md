# 9장. 디스크 관리

> 하드디스크의 관리 기법에 대해 살펴본다.
>
> - 디스크의 구조
> - 디스크 스케줄링 기법
>   - 디스크 스케줄링과 엘리베이터 스케줄링은 유사한 문제이다.
> - 저전력 디스크 관리 기법

## 1. 디스크의 구조

- <u>디스크 외부</u>에서는 `디스크`를 일정한 크기의 저장공간들로 이루어진 `1차원 배열`처럼 취급하게 된다.

  이 일정한 크기의 저장공간을 **논리블록(logical block)**이라고 한다.

  - 디스크에 데이터가 저장될 때

  - 디스크 외부로 입출력이 일어날 때

    => **논리블록 단위**로 저장되거나, **논리블록 단위**로 전송된다.

    1. 논리블록에 저장된 데이터를 접근하기 위해서는 `배열`을 접근하는 것처럼 `해당 블록의 인덱스 번호`를 디스크에 전달해야 한다.

    2. 그러면 `디스크 컨트롤러`는 해당 논리블록이 저장된 물리적 위치를 찾아 요청된 데이터에 대한 입출력을 수행한다.

       > **디스크 컨트롤러**
       >
       > - 디스크를 실제로 작동시키는 일은 디바이스 `컨트롤러(HW)`가 컨트롤러 안의 **펌웨어 코드(SW)**의 지시를 받아서 하는 것이다. (컴퓨터 외부에서 동작)
       > - 로컬 버퍼를 가짐 (일종의 data register)
       > - 제어 정보를 위해 control register, status register를 가짐
       >   - CPU가 지시를 내리기 위해 사용하는 제어 정보를 저장한다.

- 각 논리블록이 저장되는 <u>디스크 내부</u>의 물리적인 위치를 **섹터(sector)**라고 부른다.

> **논리블록** 하나가 **섹터** 하나와 1 대 1로 매핑되어 데이터가 저장된다.

<img src="images/09_disk_structure.jpg" style="zoom:50%;" />

디스크의 물리적인 구조는 **마그네틱의 원판**으로 구성된다.

각각의 원판은 **트랙(track)**으로 구성되고, 각 트랙은 **섹터**로 나뉜다.

- 섹터에는 최소한의 단위 정보가 저장된다.

여러개의 원판에서 상대적 위치가 동일한 트랙들의 집합을 **실린더(cylinder)**라고 부른다.

- `섹터 0`은 최외곽 실린더의 첫 번째 트랙에 있는 첫 번째 섹터이다. 

**[디스크에 데이터를 읽고 쓰기]**

1. 암(arm)이 해당 섹터가 위치한 `실린더`로 이동
2. 원판이 회전하여 디스크 헤드가 저장된 `섹터` 위치에 도달



## 2. 디스크 스케줄링

**디스크에 대한 접근시간(access time)**은 `탐색시간`과 `회전지연시간`, `전송시간`으로 구분된다.

- 탐색시간(seek time)

  : 디스크 헤드를 해당 `실린더` 위치로 이동시키는 데 걸리는 시간

  즉 접근하려는 데이터가 원판의 안쪽에 있는지 바깥쪽에 있는지에 따라 **헤드를 움직이는 데 걸리는 시간**

- 회전지연시간(rotational latency)

  : **디스크가 회전**해서 해당 `섹터`가 헤드 위치에 도달하기까지 걸리는 시간 

- 전송시간(transfer time)

  : 해당 `섹터`가 헤드 위치에 도달한 후 **데이터를 실제로 `섹터`에 읽고 쓰는 데 소요되는 시간**

> **디스크 입출력의 효율**을 높이기 위해서는 디스크 입출력에 소요되는 접근시간을 최소화해야 한다.
>
> - 회전지연시간, 전송시간 - 상대적인 수치가 작고 `운영체제`가 통제하기 힘든 부분이다.
> - 탐색시간 - `운영체제`는 탐색시간을 줄이기 위해 헤드의 움직임을 최소화하는 **디스크 스케줄링** 작업을 할 수 있다.

- 디스크 스케줄링(disk scheduling)

  : 효율적인 디스크 입출력을 위해, **여러 `섹터`들에 대한 입출력 요청들을 어떠한 순서로 처리할 것인지** 결정하는 메커니즘 

  (해당 `섹터`들을 포함하는 `실린더` 위치의 방문 순서를 결정)

  - 목표 - 디스크 헤드의 이동거리 줄이기

### 1) FCFS 스케줄링

FCFS(First Come First Served) 스케줄링은 디스크에 **먼저 들어온 요청을 먼저 처리**하는 방식이다.

최악의 경우 입출력 요청이 디스크의 한쪽 끝과 반대쪽 끝에 번갈아 도착한다면, 헤드는 디스크를 계속 왕복하며 일을 처리해야 하므로 매우 **비효율적**이다.

- 입출력 요청이 들어온 실린더 위치: 99, 184, 36, 123, 15, 125, 66, 68

- 실린더 개수 200개

- 실린더 0: 디스크 원판의 가장 안쪽 실린더

  실린더 199: 가장 바깥쪽 실린더

  <img src="images/09_FCFS.jpg" style="zoom:50%;" />

- 현재 디스크 헤드가 54번 실린더에 있을 경우, 헤드는 54에서 출발해 99, 184, 36, 123과 같이 요청이 들어온 순서대로 이동한다.

  => 총 헤드가 이동한 거리는 644가 된다.

### 2) SSTF 스케줄링

SSTF(Shortest Seek Time First) 스케줄링은 **헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리**한다.

우체부가 같은 지역으로 가는 우편물들을 그룹화해 배달하는 것과 유사한 방식이다.

- 입출력 요청이 들어온 실린더 위치: 99, 184, 36, 123, 15, 125, 66, 68

- 실린더 개수 200개

- 실린더 0: 디스크 원판의 가장 안쪽 실린더

  실린더 199: 가장 바깥쪽 실린더

  <img src="images/09_SSTF.jpg" style="zoom:50%;" />

- 현재 디스크 헤드가 54번 실린더에 있을 경우, 가장 가까운 66번 실린더의 요청을 가장 먼저 처리한다.

- 그 후 66번에서 가장 가까운 68번, 그다음에는 68에서 가장 가까운 36번, 이런 순서로 이동하며 요청을 처리한다. 

  => 총 헤드가 이동한 거리는 236이 된다.

SSTF는 헤드의 이동거리를 줄여 **디스크의 입출력 효율성을 증가**시키지만, <u>헤드의 이동거리 측면에서 가장 우수한 알고리즘은 아니다</u>.

- 기아 현상(starvation)

  : 현재의 헤드 위치로부터 가까운 곳에서 지속적인 요청이 들어올 경우, 헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야 하는 문제가 발생할 수 있다.

### 3) SCAN 알고리즘

SCAN 알고리즘은 **헤드가 디스크 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리**한다.

즉 디스크의 <u>어떠한 위치에 요청이 들어오는가와 상관없이</u>, 헤드는 정해진 방향으로 이동하면서 길목에 있는 요청들을 처리하며 지나가는 것이다.

<img src="images/09_SCAN2.JPG" style="zoom:80%;" />

버스가 일정 경로에 따라 움직이며 정류장에서 기다리고 있는 사람들을 태우는 것과 유사한 방식이다.

또한 엘리베이터에서 사용하는 알고리즘과 유사하기 때문에 `엘리베이터 스케줄링 알고리즘(elevator scheduling algorithm)`이라고도 부른다.

- 입출력 요청이 들어온 실린더 위치: 99, 184, 36, 123, 15, 125, 66, 68

- 실린더 개수 200개

- 실린더 0: 디스크 원판의 가장 안쪽 실린더

  실린더 199: 가장 바깥쪽 실린더

<img src="images/09_SCAN.jpg" style="zoom:50%;" />

- 현재 디스크 헤드가 54번 실린더이고 디스크 헤드가 0번 실린더 방향으로 이동하고 있는 경우, 가는 길목에 존재하는 36번과 15번 실린더 위치에 들어온 요청을 처리한다.

- 0번 실린더에 도착한 후에는 이동 방향을 바꾸어 199번 실린더를 향해 이동하면서 가는 길목에 존재하는 모든 요청들을 차례로 처리한다.

  => 총 헤드가 이동한 거리는 238이 된다.

`효율성`과 `형평성`을 모두 만족하는 알고리즘이다.

- 효율성

  : `FCFS`처럼 불필요한 헤드의 이동이 발생하지 않는다.

  한쪽 끝에서 다른 쪽 끝으로 한 번만 이동하면 현재 큐에 들어온 모든 요청을 처리할 수 있으므로 <u>이동거리 측면에서 매우 효율적</u>이다.

- 형평성

  : 헤드가 전체 실린더를 한 번 스캔하는 시간이면 기다리던 모든 요청이 처리되므로, `SSTF`처럼 **일부 요청이 지나치게 오래 기다리는 현상이 발생하지 않는다**.

**[위치에 따른 탐색시간의 편차]**

`SCAN 알고리즘`에서 모든 실린더 위치의 기다리는 시간이 공평한 것은 아니다.

제일 안쪽이나 제일 바깥쪽 위치보다는 **가운데 위치가 `기다리는 평균시간`이 더 짧기 때문이다**.

=> 헤드가 **가운데 위치를 지나가는 주기**는 양 끝을 지나가는 주기의 **절반**에 불과하다.

- ex) 헤드가 가장자리인 0번이나 199번 실린더를 막 지나가고 나서 해당 지점에 요청이 들어왔다면, 반대쪽 끝까지 헤드가 갔다 와야 서비스를 받을 수 있으므로 헤드의 이동거리 400(= 200+200)이 지난 후에야 서비스가 가능하다.
- 반면 100번 실린더의 경우, 헤드가 가장자리까지 갔다가 다시 돌아오는 거리는 200에 불과하다.

> SCAN 알고리즘의 `위치에 따른 탐색 시간의 편차`를 보완하기 위해 **C-SCAN 알고리즘**이 제안되었다.

### 4) C-SCAN 알고리즘

C-SCAN(Circular-SCAN) 알고리즘은 `SCAN`처럼 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다.



### 5) LOOK과 C-LOOK 알고리즘

