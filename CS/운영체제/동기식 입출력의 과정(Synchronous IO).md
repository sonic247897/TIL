# 동기식 입출력의 과정(Synchronous I/O)

<img src="images/03_IO.jpg" style="zoom:60%;" />

1. 프로그램 A가 실행 중에 디스크에서 어떤 데이터를 읽어오는 명령을 만나게 되면 프로그램 A는 **시스템 콜**을 통해 CPU에게 일종의 **소프트웨어 인터럽트**를 발생시킨다. (`사용자 프로그램`이 직접 인터럽트 라인을 set하는 명령어를 실행한다)

2. CPU는 지금까지 프로그램 A의 코드를 실행하던 일을 멈추고 현재의 상태를 **PCB(Process Control Block)**에 저장한 후, 인터럽트에 의해 처리해야 할 **커널(운영체제)의 루틴**으로 이동한다. 

   (= CPU의 제어권이 사용자 프로그램에서 `운영체제`로 넘어간다)

3. 처리루틴으로 이동하면 CPU는 `컨트롤러`에게 입출력 연산을 요청한다.

4. 그러면 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 **로컬버퍼**로 읽어온다.

5. 읽어오는 동안에 프로그램 A는 CPU를 다시 할당받지 못하게 된다. `운영체제`는 프로그램 A가 입출력 연산을 요청했으므로 CPU를 할당해도 명령을 수행하지 못한다는 사실을 **봉쇄 상태**로 표시한다. 

   그리고 CPU를 다른 프로그램 B에 할당해 계속 CPU가 일을 할 수 있도록 한다.

6. 원하는 정보가 로컬버퍼로 다 들어오면 `컨트롤러`는 CPU에게 입출력이 완료되었다는 사실을 인터럽트를 발생시켜 알린다. 이때 발생하는 인터럽트는 **하드웨어 인터럽트**에 해당한다.

7. 프로그램 B를 수행 중이던 CPU는 수행하던 지점 및 상태를 **PCB**에 저장해놓고 인터럽트를 처리하게 된다.

8. **[인터럽트 처리루틴]은 로컬버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고, A의 봉쇄 상태를 해제시켜 이제 A에게 CPU를 할당해도 됨을 표시한다.**

9. 그러면 A는 CPU를 기다리는 줄에 다시 서게 된다.

10. 그 후 원래 수행하던 프로그램 B의 지점으로 돌아가서 하던 업무를 계속 수행하게 된다.

11. 프로그램 A는 CPU를 기다리는 줄에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행하게 된다.



일반적으로 운영체제에게 입출력 요청을 할 경우 해당 프로그램의 입출력이 완료될 때까지 그 프로그램을 봉쇄시키는 **동기식 입출력**을 사용한다. 다수의 입출력이 동시에 요청될 때, 운영체제는 장치별로 입출력 처리를 기다리는 프로세스를 줄 세워 관리함으로써(장치마다 큐를 둠) `동기성`을 보장하게 되는 것이다.

