# 자식 프로세스 생성 과정

1. 프로세스가 `fork()` 시스템 콜을 하게 되면 CPU의 제어권이 **커널**로 넘어가게 되고, 커널은 `fork()`를 호출한 프로세스를 복제해 자식 프로세스를 생성하게 된다.

   실제로 `fork()`를 통해 생성된 프로세스는 부모 프로세스와 **모든 문맥**을 동일하게 가지고 있다.

   - 즉 부모 프로세스의 주소 공간, 프로그램 카운터 등 레지스터 상태, PCB 및 커널스택 등을 그대로 복제하므로
   - 자식 프로세스는 부모 프로세스의 처음부터 수행을 시작하는 것이 아니라 부모 프로세스가 현재 수행한 시점(프로그램 카운터 지점)부터 수행하게 된다.

   > 부모 프로세스가 메인함수의 첫 번째 줄부터 한 줄씩 코드를 수행하다가 `fork()`라는 라인에 이르면 자신과 똑같은 프로세스를 하나 생성하게 되는데, 현재 그 라인까지 수행했다는 기억조차도 똑같은 자식 프로세스가 생성되는 것이다.
   >
   > - 인간으로 말하자면 기억까지 동일한 복제인간을 만드는 것과 같다.
   >
   > 또, 부모와 마찬가지로 방금 전에 자기 자신을 '복제했다'는 기억을 가지게 된다. 그래서 복제된 프로세스는 자기가 복제본이 아니라 원본이며, 자기를 복제해서 복제본이 생성되었다는 기억을 갖게 되는 것이다.
   > 다만, 이 프로세스가 복제된 프로세스라는 사실을 알 수 있는 단서가  한 가지 있다.
   >
   > - `fork()` 함수의 결과값으로 원본에게는 양수를 주고 복제본에게는 0을 준다.
   >
   > - 따라서 조건문을 사용해 원본 프로세스와 복제본 프로세스가 다른 작업을 하도록 프로그램을 작성할 수 있다.
   >
   >   ![](images/05_fork.jpg)

   다만 유일하게 **프로세스 식별자**는 부모 프로세스와 다르다.

2. `fork()` 시스템 콜을 통해 프로세스를 생성한 후 그 결과값에 따라 부모 프로세스와 자식 프로세스에게 다른 작업을 수행시킬 수는 있지만, 이는 조건문에 의한 분기(branch)일 뿐 사실상 두 프로세스 모두 **동일한 코드**의 내용을 가진다.
   따라서 자식 프로세스에게 부모와는 다른 **독자적인 프로그램**을 수행시킬 수 있는 메커니즘이 필요하다.
   
   - 유닉스에서는 프로세스의 **주소 공간**에 새로운 프로그램을 덮어씌우고 첫 부분부터 다시 실행을 시작하도록 하는 `exec()` 시스템 콜을 지원한다.

### 프로세스와 관련된 시스템 콜

- fork()

- exec()

  - 프로세스의 생성과 관련된 `fork()`, `exec()` 등은 사용자 프로세스가 직접 수행할 수 없는 **특권명령**에 해당한다.

    따라서 운영체제에 서비스의 대행을 요청하는 **시스템 콜**을 통해서만 수행이 가능하다.

- exit()

  : 프로세스가 자발적으로 종료될 때, 프로그램이 마쳐지는 코드 부분에 `exit()`라는 시스템 콜을 호출한다.

  (프로그램이 종료되는 지점에 컴파일러가 자동으로 삽입한다)

  종료를 통보받은 운영체제는 이 프로세스로부터 자원을 회수하고 시스템 내에서 이 프로세스를 정리하게 된다.

- wait()

  : 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 `봉쇄` 상태에 머무르도록 할 때 사용된다.

  `fork()` 후에 `wait()`를 호출하면 **커널**은 자식 프로세스가 종료될 때까지 부모 프로세스를 `봉쇄` 상태에 머무르게 하고, 자식 프로세스가 종료되면 부모를 `준비` 상태로 변경시킨다.

  - 이러한 방식으로 부모 프로세스와 자식 프로세스 간의 **동기화(synchronization)**가 가능해진다.
  - 부모 프로세스는 일반적인 `봉쇄` 상태에서처럼 자원을 기다리며 줄 서 있는 것이 아니라 자식 프로세스가 종료되기를 기다리며 **`수면(sleep)`** 상태에 머무르게 되는 것이다.

