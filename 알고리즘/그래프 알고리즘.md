# 그래프 알고리즘

> - DP, 브루트포스 - 방법
> - 그래프 알고리즘 - `문제의 상황을 그래프로 모델링 후` 여러가지 알고리즘 실행. **알고리즘은 변하지 않고 어떻게 문제의 상황을 그래프로 만들어야 하는지가 가장 중요**

- 정점(Node, Vertex)과 간선(Edge)으로 이루어진 자료구조
- **G = (V, E)**



## 1. 용어

- `경로(Path)` : 정점A에서 정점B로 가는 경로

  `사이클(Cycle)` : 정점A에서 다시 정점A로 돌아오는 경로

- `방향 그래프(Directed Graph)` : 간선에 방향이 있는 그래프

  `무방향 그래프(Undirected Graph)` : 간선에 방향이 없는 그래프

- `루프(Loop)` : 간선의 양 끝 점이 같은 경우

  `가중치(Weight)` : 간선에 가중치가 있는 경우. ex) 거리, 시간, 비용 등..

  ​	=> 가중치가 없는 경우에는 가중치=1 이라고 생각하면 된다.

  `차수(Degree)` : 정점과 연결되어 있는 간선의 개수

  ​	=> 방향 그래프의 경우에는 In-degree와 Out-degree로 나누어서 차수를 계산한다.




## 2. 그래프의 표현

- 그래프 저장 방법

- **한 정점 X와 연결된 간선을 효율적으로 찾는 구조** `(탐색이 용이하도록 구현한 구조들)`

  1) 인접 행렬 (Adjacency matrix)

  ​	: 정점의 개수를 V라고 했을 때 V*V 크기의 2차원 배열을 이용

  ​		`A[i][j]` = w (i -> j 간선이 있을 때, 그 가중치)

  ​		`A[i][j]` = 0 (간선이 없을 때)

  - 공간 복잡도: **O(V^2)**

    시간 복잡도(한 정점과 연결된 모든 간선을 탐색하는 데 걸리는 시간): **O(V)**

  2) 인접 리스트 (Adjacency list)

  ​	: 리스트를 이용해서 구현

  ​		`A[i]` = i와 연결된 정점을 리스트로 포함하고 있음 (가중치가 있는 경우 가중치도 같이 저장)

   - **리스트는 크기를 동적으로 변경할 수 있어야 한다.**

     	- Java의 ArrayList

  - 공간 복잡도: **O(E)**

    시간 복잡도(한 정점과 연결된 모든 간선을 탐색하는 데 걸리는 시간): **O(1)** (= O(각 정점의 차수))



## 3. 그래프의 탐색

> **목적**: 임의의 정점에서 시작하여, 연결되어 있는 `모든 정점을 1번씩만 방문하는 것`
>
> - DFS : 깊이 우선 탐색 (Stack)
> - BFS : 너비 우선 탐색 (Queue)

- DFS - 사람 한명이 왔다갔다 하는 방식(미로탐색 알고리즘 모방)
  BFS - 한 번 시도될 때마다 사람이 여러명 복제되는 방식

``` java
// DFS
void dfs(int x){
    check[x] = true;
    int size = a[x].size();
    for(int i=0; i<s; ++i){
        int y = a[x][i];
        if(check[y] == false)
        	dfs(y);
    }
}
```

