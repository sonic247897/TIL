# 그리디 알고리즘

- 그 순간에 가장 좋다고 생각하는 것을 선택하면서 답을 찾아가는 알고리즘

- 최종적으로는 답이 아닐 수도 있다.

  

**[거스름돈 문제]**

- 돈을 거슬러 줄 때, 사용하는 지폐와 동전의 개수를 최소로 하는 문제

  > 그리디 알고리즘> 가장 큰 액수부터 사용한다.

- **배수 관계를 만족해야 그리디 방법을 사용할 수 있다.** 

  `A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수` => `Ai를 Ai+1/Ai개 사용했다면 Ai+1 1개로 변경하면 더 최소가 된다.` (Ai=1000원, Ai+1=5000원 이면 Ai는 최대 (Ai+1/Ai) -1 = 4장 쓸 수 있다.)

  ex) 1, 5, 10, 50, 100, 500 .. (2배, 5배)
  
  
  

**[회의실 배정]**

- 한 개의 회의실이 있을 때 이를 사용하고자 하는 n개의 회의들에 대해서

- 각 회의에 대해 시작 시간과 끝 시간이 주어져 있을 때, 겹치지 않게 회의할 수 있는 최대 회의 수 구하기 (한 회의가 끝나는 동시에 다음 회의가 시작될 수 있다)

  > 그리디 알고리즘> 가장 빨리 끝나는 회의부터 시작한다.

  - 예외: 시작시간 = 끝시간 회의 존재 **(끝나는 시간이 같으면 시작  시간이 빠른 회의가 앞에 와야 한다)**



## 1. 증명법

- `이 문제는 그리디 알고리즘이 아니다.` 증명 => **반례**만 찾으면 된다.

- `이 문제는 그리디 알고리즘이다.` 증명 => **수학적으로 증명해야 한다!** 

  > **증명은 문제마다 다르다.**
  >
  > <그리디 수식 증명 방법> (대부분)
  >
  > 1. 어떤 그리디의 방법이 정답이다. (가정)
  > 2. 여기서 변화를 주었을 때 더 작아지면 안됨 (즉, 크거나 같아야 가정이 성립됨)
  >  => 문제에 따라서 대소관계가 반대가 될 수도 있다.
  
  

## 2. Problem Solving

- **활동 선택 문제 (Activity selection problem)** 
  - dp로 푸는데 시간이 너무 많이 걸리는 문제들 중에, 그리디로 풀 수 있는 방법이 존재하는 문제들 
  - (회의실 배정)
- 연산을 2번 하면 원래대로 돌아오는 문제
  - **연산을 1번만 사용하거나, 아예 사용하지 않거나** 둘 중 하나만 해야 하는 문제
  - 어떤 한 칸에 대해 연산여부를 결정하고(연산할 지/말 지 두 경우에 대해 푼다), `연쇄적으로 각각의 칸을 바꿀 수 있는 방법이 1개가 되도록 만들어야 한다.` => 모두 정한 후 남은 부분 검사
  - (행렬, 전구와 스위치, 동전 뒤집기)

- Knapsack Problem 변형 문제

  - 무게, 가격 중에서 **문제에서 최대, 최소를 구하는 값이 기준**이 된다.

  - 두 가지 방법으로 풀 수 있다.
    1) 각 물건이 어떤 가방에 들어가야 하는지 조사
    2) 각 가방이 있을 때 이 가방에 들어가는 가장 비싼 물건 구하기

    ​	=> `BST(JAVA의 TreeMap) 자료구조를 이용하면 효율적인 삽입, 삭제가 가능하다.`

  - (보석 도둑, 순회강연)