# 세그먼트 트리

세그먼트 트리는 `RMQ`라는 문제를 풀기 위한 자료구조이다.



## RMQ (Range Minimum Query)

> 구간의 최소값 구하기

**배열** A[]가 있고, 다음과 같은 `연산(=쿼리)`를 수행해야 한다.

- 최소값: A[i], ... , A[j] 중에서 최소값을 찾아 출력한다.

  - 이러한 연산이 1개 주어진다.

    : (i, j) 쌍이 1개 주어지므로 시간복잡도는 **O(N)**

  - **이러한 연산이 총 Q개 주어진다.**

    : (i, j) 쌍이 Q개 주어지므로 시간복잡도는 **O(N*Q)**

    => N, Q ≤ 10^5 이면 시간 초과가 발생한다.

### 1. 다 해보기

`쿼리`: A[i], ... , A[j] 중에서 최소값을 찾아 출력한다. 

- 쿼리가 1개일 때는 가장 빠른 방법이다.

- **O(N)**

``` java
int min = a[i];
for(int k=i+1; k<=j; ++k){
    if(a[k] < min)
        min = a[k];
}
```

- 쿼리가 Q개일 때는 **O(N*Q)**의 시간복잡도를 갖는다.



### 2. 루트N으로 나누기 (square-root decomposition)

N개의 수를 **√N개의 그룹으로 나누는 방법**이다.

각 그룹에 들어있는 수의 개수도 √N개이다.

> **그룹의 개수**와 **그룹에 포함된 수의 개수**가 모두 √N이라는 장점을 이용하는 방법

- N = 11이면 √11 = 3.xx... 이다.

  정수를 사용할 것이므로 R = 3이라고 한다.

- 배열 A[]를 R개의 그룹으로 나눈 다음에, Group[i]에 i번 그룹의 최소값을 저장하는 방식

#### 1) 선처리 (preprocessing)

쿼리를 효율적으로 수행하기 위한 데이터를 먼저 준비하는 것

- **O(N)**

``` java
for(int i=0; i<n; ++i){
    if(i%r == 0)
        group[i/r] = a[i]; // 그룹의 첫 번째 수를 저장
    else{
    	if(a[i] < group[i/r]) // 그룹에서 가장 작은 수를 저장
            group[i/r] = a[i];
    }
}
```

#### 2) 쿼리

최소값을 구하는 쿼리 i, j는 두 가지 경우가 있다. (i ≤ j)

1. i와 j가 같은 그룹인 경우

   : **해당 그룹 전체를 순차검색**해도 된다. 

   - 그룹의 크기가 √N이기 때문에 시간복잡도가 **O(√N)**

2. i와 j의 그룹이 다른 경우

   : 3가지 경우로 나눌 수 있다.

   - i가 들어있는 그룹

     : 시작 그룹에 들어있는 수의 개수는 √N개

   - i와 j 사이에 들어있는 그룹

     : 시작과 끝 그룹 사이에 있는 그룹의 수는 √N개

   - j가 들어있는 그룹

     : 끝 그룹에 들어있는 수의 개수는 √N개

   전부 O(3*√N)이므로 시간복잡도는 **O(√N)**


- **O(√N)**

``` java
while(true){
    ans = 
}
```

- 선처리에 O(N), 쿼리를 한 번 수행하는데 O(√N)이므로
- 쿼리를 Q번 수행하는 시간복잡도는 **O(N+Q√N)**
- 공간복잡도는 O(N)



### 3. 다이나믹 프로그래밍

> LCA와 비슷한 방법으로 접근하는 방법

