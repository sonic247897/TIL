# 수학

## 1. 나머지 연산(Modular Arithmetic)

> (A + B) % M = ((A % M) + (B % M)) % M
>
> (A * B) % M = ((A % M) * (B % M)) % M
>
> (A - B) % M = ((A % M) - (B % M) **+ M**) % M

- 나누기의 경우에는 성립하지 않는다. (`Modular Inverse`를 구해야 함)

- 뺄셈의 경우에는 **중간 결과에 음수가 나올 수 있기 때문에 M을 더해준다**.

  ``` java
  0 ≤ a%c < c
  0 ≤ b%c < c 이므로
  -c < (a%c - b%c) < c 의 결과가 나온다.
  => +c를 더해주면,
  	0 < (a%c - b%c + c) < 2c 가 되어 0보다 큰 값을 가지므로,
  	이 상태에서 다시 c로 나눠주면 원하는 결과가 나온다.
  ```




### Problem Solving

- [정답을 ~(정수)~로 나눈 나머지를 출력하라]

  => 매번 나누면 된다!



## 2. 최대공약수(GCD, Greatest Common Divisor)

> **최대공약수**는 두 수 A와 B의 공통된 약수 중에서 가장 큰 정수이다.

- 최대공약수가 1인 두 수를 `서로소(Coprime)`라고 한다.

- 구하는 방법

  1. 2부터 min(A,B)까지 모든 정수로 나누어 보기

     - 가장 쉬운 방법
   - **O(N)**
  
  2. 유클리드 호제법
  
   - `GCD(a,b) = GCD(b,r)` (r : a, b 중 큰 수를 작은 수로 나눈 나머지)
  
       [증명]
       
       > A = a * G, B = b * G 
       > (G는 최대공약수/ a, b는 **서로소** - 더 이상 공약수가 없어야 하므로)
       > => <u>A % B = r</u> 일 때, `GCD(B, r) = G` 인지 확인하면 된다.
       > 	<u>A = q * B + r</u>
       >     (a * G) = q * (b * G) + r
       >
       > ​	∴ r = (a - qb) * G , B = b * G
       >
       > => 식을 전개해서 구한 r과 B가 `GCD(B, r) = G` 를 만족하는지 확인하기 위해서는
       >
       > ​	a - q * b 와 b가 **서로소**이면 된다.
       >
       > ​	(귀류법) 만약에 a - q * b와 b가 서로소가 아니라면, 아래와 같은 공통약수 p를 가진다.
       >
       > ​	a - q * b = m * p
       >
       > ​	<u>b = n * **p**</u>
       >
       > ​	a - q * (np) = (mp)
       >
       > ​	<u>a = (nq + m) * **p**</u>
       >
       > ​	∴ a, b가 공통약수 p를 가지므로 서로소가 아니게 된다.
       >
       > ​	이것은 a, b가 서로소라는 처음의 가정에 **모순**된다. 
  
     - r이 0이면 그 때의 b가 최대 공약수
  
       => a, b 중 큰 수를 작은 수로 나눈 나머지가 0 이라는 뜻이므로, 나누어 떨어지는 최초의 약수이기 때문에 **최대공약수**가 된다.
  
       > b = aq1 + r1 (0 < r1< a)
       >
       > a = r1q2 + r2 (0 < r2 < r1)
       >
       > r1 = r2q3 + r3 (0 < r3 <r2)
       >
       > ....
       >
       > r(n-2) = r(n-1)q(n) + r(n) (0 < r(n) < r(n-1))
       >
       > r(n-1) = r(n)q(n+1)
       >
       > ∴ gcd(a, b) = r(n)
  
     - **O(lgN)**
  
     ``` java
     // 재귀함수 구현
     int gcd(int a, int b){
         if(b == 0){
             return a;
       } else{
             return gcd(b, a%b); // 호출하면서 a > b를 만든다. 
       }
     }
     // 반복문 구현
     // => 재귀함수가 항상 하나의 다른 함수를 호출하고 있기 때문에 반복문의 형태로 바꿀 수 있다.
     int gcd(int a, int b){
         while(b != 0){
             int r = a%b;
             a = b;
             b = r;
         }
         return a;
     }
     ```
  
     - 세 수의 최대공약수
  
       GCD(a, b, c) = GCD(GCD(a, b), c)



## 3. 최소공배수(LCM, Least Common Multiple)

